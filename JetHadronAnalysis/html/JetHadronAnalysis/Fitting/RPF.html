<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>JetHadronAnalysis.Fitting.RPF API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>JetHadronAnalysis.Fitting.RPF</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from collections import OrderedDict
import warnings
import numpy as np
from JetHadronAnalysis.Types import AnalysisType, AssociatedHadronMomentumBin, TriggerJetMomentumBin

initial_parameter_defaults = {}
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_20_40, AssociatedHadronMomentumBin.PT_1_15)] = [
    1000042.8,
    0.0473,
    -0.000306,
    0.02,
    0.1013,
    0.03,
]  # pTtrig 20-40, pTassoc 1.0-1.5
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_20_40, AssociatedHadronMomentumBin.PT_15_2)] = [
    40000.19,
    0.0402,
    -0.0058,
    0.02,
    0.1506,
    0.03,
]  # pTtrig 20-40, pTassoc 1.5-2.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_20_40, AssociatedHadronMomentumBin.PT_2_3)] = [
    4006.86,
    0.0414,
    0.0015,
    0.02,
    0.234,
    0.03,
]  # pTtrig 20-40, pTassoc 2.0-3.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_20_40, AssociatedHadronMomentumBin.PT_3_4)] = [
    56.84,
    0.0636,
    -0.00766,
    0.02,
    0.237,
    0.03,
]  # pTtrig 20-40, pTassoc 3.0-4.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_20_40, AssociatedHadronMomentumBin.PT_4_5)] = [
    8.992,
    0.1721,
    -0.0987,
    0.02,
    0.233,
    0.03,
]  # pTtrig 20-40, pTassoc 4.0-5.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_20_40, AssociatedHadronMomentumBin.PT_5_6)] = [
    2.318,
    -0.0508,
    -0.143,
    0.02,
    0.1876,
    0.03,
]  # pTtrig 20-40, pTassoc  5.0-6.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_20_40, AssociatedHadronMomentumBin.PT_6_10)] = [
    2.076,
    -0.0886,
    0.12929,
    0.02,
    0.0692,
    0.03,
]  # pTtrig 20-40, pTassoc 6.0-10.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_40_60, AssociatedHadronMomentumBin.PT_1_15)] = [
    1,
    0.02,
    0.005,
    0.02,
    0.2,
    0.03,
]  # pTtrig 40-60, pTassoc 1.0-1.5
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_40_60, AssociatedHadronMomentumBin.PT_15_2)] = [
    1,
    0.02,
    0.005,
    0.02,
    0.2,
    0.03,
]  # pTtrig 40-60, pTassoc 1.5-2.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_40_60, AssociatedHadronMomentumBin.PT_2_3)] = [
    1,
    0.02,
    0.005,
    0.02,
    0.2,
    0.03,
]  # pTtrig 40-60, pTassoc 2.0-3.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_40_60, AssociatedHadronMomentumBin.PT_3_4)] = [
    1,
    0.02,
    0.005,
    0.02,
    0.2,
    0.03,
]  # pTtrig 40-60, pTassoc 3.0-4.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_40_60, AssociatedHadronMomentumBin.PT_4_5)] = [
    1,
    0.02,
    0.005,
    0.02,
    0.2,
    0.03,
]  # pTtrig 40-60, pTassoc    4.0-5.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_40_60, AssociatedHadronMomentumBin.PT_5_6)] = [
    1,
    0.02,
    0.005,
    0.02,
    0.2,
    0.03,
]  # pTtrig 40-60, pTassoc 5.0-6.0
initial_parameter_defaults[(AnalysisType.SEMICENTRAL, TriggerJetMomentumBin.PT_40_60, AssociatedHadronMomentumBin.PT_6_10)] = [
    1,
    0.02,
    0.005,
    0.02,
    0.2,
    0.03,
]  # pTtrig 40-60, pTassoc 6.0-10.0

bounds = [[0.0,  -0.2, -0.2, -0.1, -0.005, -0.02], [1e8,  0.2, 0.3, 0.10, 0.80, 0.15]]

resolution_parameters = {}
resolution_parameters[AnalysisType.SEMICENTRAL] = OrderedDict([
    (&#34;R2&#34;, 0.7703651242647157),
    (&#34;R4&#34;, 0.5046126852106662),
    (&#34;R6&#34;, 0.3020062445564112),
    (&#34;R8&#34;, 0),
])
resolution_parameters[AnalysisType.CENTRAL] = OrderedDict([
    (&#34;R2&#34;, 0.6192508430757114),
    (&#34;R4&#34;, 0.34878092755772117),
    (&#34;R6&#34;, 0.18777865138044672),
    (&#34;R8&#34;, 0),
])

def vtilde( n, phis, c, R2, R4, R6, R8):
    def vtilde_( v2, v3, v4):
        denom = (1 + 2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)
        if n&lt;=0 or n&gt;=5: return 0
        if n==1:
            return 0 #v1
        if n==2:
            return (v2 + np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + (v4)*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + (v2)*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4 + (v4)*np.cos(6*phis)*np.sin(6*c)/(6*c)*R6) / denom
        if n==3:
            return v3 
        if n==4:
            return (v4 + np.cos(4*phis)*np.sin(4*c)/(4*c)*R4 + (v2)*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + (v2)*np.cos(6*phis)*np.sin(6*c)/(6*c)*R6 + (v4)*np.cos(8*phis)*np.sin(8*c)/(8*c)*R8) / denom
        else:
            return 0
    return vtilde_

def btilde( phis, c, R2, R4, R6, R8):
    def btilde_(B, v2, v4):
        return np.pi*B*(1+2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)
    return btilde_

def background(phis, c, R2, R4, R6, R8):
    def background_(dPhi, B,  v2, v3, v4,  va2, va4):
        btilde_func = btilde(phis, c, R2, R4, R6, R8)
        return btilde_func(B, v2, v4)*(1+2*vtilde(3, phis, c, R2, R4, R6, R8)( v2, v3, v4)*np.cos(1*dPhi) +2*vtilde(2, phis, c, R2, R4, R6, R8)( v2, v3, v4)*va2*np.cos(2*dPhi) +2*vtilde(3, phis, c, R2, R4, R6, R8)( v2, v3, v4)*np.cos(3*dPhi) + 2*vtilde(4, phis, c, R2, R4, R6, R8)( v2, v3, v4)*va4*np.cos(4*dPhi))
    return background_

def background_err( phis, c, R2, R4, R6, R8):
    
    def background_err_(dPhi, B, v2, v3, v4, va2, va4, pcov):
        bground = background(phis, c, R2, R4, R6, R8)
        btilde_func = btilde(phis, c, R2, R4, R6, R8)

        #dbddPhi = np.pi*btilde_func(B, v2, v4)*(-2*v1*np.sin(1*dPhi) -4*vtilde(2, phis, c)(v1, v2, v3, v4)*va2*np.sin(2*dPhi) -6*v3*np.sin(3*dPhi) - 8*vtilde(4, phis, c)(v2, v4)*va4*np.sin(4*dPhi))

        dbdB = bground(dPhi, B, v2, v3, v4, va2, va4)/B

        #dbdv1 = btilde_func(B, v2, v4)*2*vtilde(1, phis, c)(v1, v2, v3, v4)*np.cos(1*dPhi)/v1


        v2_first_term = (-(2*R2*va2*np.cos(2*dPhi)*np.cos(2*phis)*np.sin(2*c)*(v2+R2*np.cos(2*phis)*np.sin(2*c)/(2*c) + R2*v4*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v2*np.cos(4*phis)*np.sin(4*c)/(4*c)))/(c*(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/2*c +2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))**2))
        v2_second_term = ((2*va2*np.cos(2*dPhi)*(1+R4*np.cos(4*phis)*np.sin(4*c)/(4*c)))/(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)))
        v2_third_term = ((2*va4*np.cos(4*dPhi)*(R2*np.cos(2*phis)*np.sin(2*c)/(2*c) + R6*np.cos(6*phis)*np.sin(6*c)/(6*c)))/(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)))
        v2_fourth_term = -(2*R2*va4*np.cos(4*dPhi)*np.cos(2*phis)*np.sin(2*c)*(v4+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + R4*np.cos(4*phis)*np.sin(4*c)/(4*c)+R6*v2*np.cos(6*phis)*np.sin(6*c)/(6*c)+R8*v4*np.cos(8*phis)*np.sin(8*c)/(8*c)))/(c*(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))**2)
        v2_bonus_term = 1/c*B*R2*np.cos(2*phis)*np.sin(2*c)*(1+2*0*np.cos(dPhi)+2*v3*np.cos(3*dPhi) + (2*va2*np.cos(2*dPhi)*(v2+R2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R2*v4*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v2*np.cos(4*phis)*np.sin(4*c)/(4*c)))/(1+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))+2*va4*np.cos(4*dPhi)*(v4+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*np.cos(4*phis)*np.sin(4*c)/(4*c)+R6*v2*np.cos(6*phis)*np.sin(6*c)/(6*c)+R8*v4*np.cos(8*phis)*np.sin(8*c)/(8*c))/(1+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)))
        
        dbdv2 = btilde_func(B, v2, v4)*(v2_first_term + v2_second_term + v2_third_term + v2_fourth_term) + v2_bonus_term
        #dbdv2 = btilde_func(B, v2, v4)*2*(va2*np.cos(2*dPhi)*(
        #    (1 + np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)
        #    /
        #    (1+2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)
        #            -(v2 + np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + (v4)*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + (v2)*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4 )*(2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2))
        #                /
        #                (1 + 2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)**2 
        #     - va4*np.cos(4*dPhi)*((v4 + np.cos(4*phis)*np.sin(4*c)/(4*c)*R4  )*(2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2))
        #     /
        #     (1 + 2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)**2) + np.pi*(B*c*2/np.pi*2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2)*(1+2*v1*np.cos(1*dPhi) +2*vtilde(2, phis, c)(v1, v2, v3, v4)*va2*np.cos(2*dPhi) +2*v3*np.cos(3*dPhi) + 2*vtilde(4, phis, c)(v1, v2, v3, v4)*va4*np.cos(4*dPhi))

        dbdv3 = btilde_func(B, v2, v4)*vtilde(3, phis, c, R2, R4, R6, R8)(v2, v3, v4)*2*np.cos(3*dPhi)

        v4_first_term = (-(2*R4*va2*np.cos(2*dPhi)*np.cos(4*phis)*np.sin(4*c)*(v2+R2*np.cos(2*phis)*np.sin(2*c)/(2*c) + R2*v4*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v2*np.cos(4*phis)*np.sin(4*c)/(4*c)))/(c*(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/2*c +2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))**2))
        v4_second_term = ((R2*va2*np.cos(2*dPhi)*np.cos(2*phis)*np.sin(2*c)/(2*c))/(c*(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))))
        v4_third_term = ((2*va4*np.cos(4*dPhi)*(1+R8*np.cos(8*phis)*np.sin(8*c)/(8*c)))/(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)))
        v4_fourth_term = -(R4*va4*np.cos(4*dPhi)*np.cos(4*phis)*np.sin(4*c)*(v4+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + R4*np.cos(4*phis)*np.sin(4*c)/(4*c)+R6*v2*np.cos(6*phis)*np.sin(6*c)/(6*c)+R8*v4*np.cos(8*phis)*np.sin(8*c)/(8*c)))/(c*(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))**2)
        v4_bonus_term = 1/(2*c)*B*R4*np.cos(4*phis)*np.sin(4*c)*(1+2*0*np.cos(dPhi)+2*v3*np.cos(3*dPhi) + (2*va2*np.cos(2*dPhi)*(v2+R2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R2*v4*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v2*np.cos(4*phis)*np.sin(4*c)/(4*c)))/(1+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))+2*va4*np.cos(4*dPhi)*(v4+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*np.cos(4*phis)*np.sin(4*c)/(4*c)+R6*v2*np.cos(6*phis)*np.sin(6*c)/(6*c)+R8*v4*np.cos(8*phis)*np.sin(8*c)/(8*c))/(1+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)))
        
        dbdv4 = btilde_func(B, v2, v4)*(v4_first_term + v4_second_term + v4_third_term + v4_fourth_term) + v4_bonus_term

        #dbdv4 = np.pi*btilde_func(B, v2, v4)*2*(va2*np.cos(2*dPhi)*(
        #    (np.cos(2*phis)*np.sin(2*c)/(2*c)*R2)*(1+2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4) 
        #    - (v2 +np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 +v4*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 +v2*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)*(2*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4))
        #    /
        #    (1 + 2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)**2 
        #    + va4*np.cos(4*dPhi)*((1+2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)-(v4+np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)*(2*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4))
        #    /
        #    (1 + 2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)**2) + np.pi*(B*c*2/np.pi*2*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)*(1+2*v1*np.cos(1*dPhi) +2*vtilde(2, phis, c)(v1, v2, v3, v4)*va2*np.cos(2*dPhi) +2*v3*np.cos(3*dPhi) + 2*vtilde(4, phis, c)(v1, v2, v3, v4)*va4*np.cos(4*dPhi))

        dbdva2 = btilde_func(B, v2, v4)*2*vtilde(2, phis, c, R2, R4, R6, R8)( v2, v3, v4)*np.cos(2*dPhi)

        dbdva4 = btilde_func(B, v2, v4)*2*vtilde(4, phis, c, R2, R4, R6, R8)( v2, v3, v4)*np.cos(4*dPhi)

        err = np.sqrt( (dbdB**2 * pcov[0,0]) + (dbdv2**2 * pcov[1,1]) + (dbdv3**2 * pcov[2,2]) + (dbdv4**2 * pcov[3,3]) + (dbdva2**2 * pcov[4,4]) + (dbdva4**2 * pcov[5,5]) +  \
            + 2*(dbdB*dbdv2 * pcov[0,1]) + 2*(dbdB*dbdv3 * pcov[0,2])+2*(dbdB*dbdv4 * pcov[0,3])+2*(dbdB*dbdva2 * pcov[0,4])+2*(dbdB*dbdva4 * pcov[0,5])\
                    + 2*(dbdv2*dbdv3 * pcov[1,2])+2*(dbdv2*dbdv4 * pcov[1,3])+2*(dbdv2*dbdva2 * pcov[1,4])+2*(dbdv2*dbdva4 * pcov[1,5])
                    + 2*(dbdv3*dbdv4 * pcov[2,3])+2*(dbdv3*dbdva2 * pcov[2,4])+2*(dbdv3*dbdva4 * pcov[2,5])
                    + 2*(dbdv4*dbdva2 * pcov[3,4])+2*(dbdv4*dbdva4 * pcov[3,5])
                    + 2*(dbdva2*dbdva4 * pcov[4,5]))
                    
        return err
    return background_err_

def simultaneous_fit(non_zero_masks, R2, R4, R6, R8, dPhi, B, v2, v3, v4, va2, va4):
    in_plane_func = background(0, np.pi/6, R2, R4, R6, R8)
    mid_plane_func = background(np.pi/4, np.pi/6, R2, R4, R6, R8)
    out_plane_func = background(np.pi/2, np.pi/6, R2, R4, R6, R8)
    
    if non_zero_masks is None:
        warnings.warn(&#34;non_zero_masks is None, using all data points&#34;)
        non_zero_masks = [np.ones(len(dPhi), dtype=bool)] * 3

    return np.hstack([in_plane_func(dPhi[non_zero_masks[0]], B, v2, v3, v4, va2, va4), mid_plane_func(dPhi[non_zero_masks[1]], B, v2, v3, v4, va2, va4), out_plane_func(dPhi[non_zero_masks[2]], B, v2, v3, v4, va2, va4)])

def simultaneous_err(non_zero_masks, R2, R4, R6, R8, dPhi, B, v2, v3, v4, va2, va4,  pcov):
    in_plane_err = background_err(0, np.pi/6, R2, R4, R6, R8)
    mid_plane_err = background_err(np.pi/4, np.pi/6, R2, R4, R6, R8)
    out_plane_err = background_err(np.pi/2, np.pi/6, R2, R4, R6, R8)

    if non_zero_masks is None:
        warnings.warn(&#34;non_zero_masks is None, using all data points&#34;)
        non_zero_masks = [np.ones(len(dPhi), dtype=bool)] * 3

    return np.hstack([in_plane_err(dPhi[non_zero_masks[0]], B, v2, v3, v4, va2, va4, pcov), mid_plane_err(dPhi[non_zero_masks[1]], B, v2, v3, v4, va2, va4, pcov), out_plane_err(dPhi[non_zero_masks[2]], B, v2, v3, v4, va2, va4, pcov)])</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="JetHadronAnalysis.Fitting.RPF.background"><code class="name flex">
<span>def <span class="ident">background</span></span>(<span>phis, c, R2, R4, R6, R8)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def background(phis, c, R2, R4, R6, R8):
    def background_(dPhi, B,  v2, v3, v4,  va2, va4):
        btilde_func = btilde(phis, c, R2, R4, R6, R8)
        return btilde_func(B, v2, v4)*(1+2*vtilde(3, phis, c, R2, R4, R6, R8)( v2, v3, v4)*np.cos(1*dPhi) +2*vtilde(2, phis, c, R2, R4, R6, R8)( v2, v3, v4)*va2*np.cos(2*dPhi) +2*vtilde(3, phis, c, R2, R4, R6, R8)( v2, v3, v4)*np.cos(3*dPhi) + 2*vtilde(4, phis, c, R2, R4, R6, R8)( v2, v3, v4)*va4*np.cos(4*dPhi))
    return background_</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.Fitting.RPF.background_err"><code class="name flex">
<span>def <span class="ident">background_err</span></span>(<span>phis, c, R2, R4, R6, R8)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def background_err( phis, c, R2, R4, R6, R8):
    
    def background_err_(dPhi, B, v2, v3, v4, va2, va4, pcov):
        bground = background(phis, c, R2, R4, R6, R8)
        btilde_func = btilde(phis, c, R2, R4, R6, R8)

        #dbddPhi = np.pi*btilde_func(B, v2, v4)*(-2*v1*np.sin(1*dPhi) -4*vtilde(2, phis, c)(v1, v2, v3, v4)*va2*np.sin(2*dPhi) -6*v3*np.sin(3*dPhi) - 8*vtilde(4, phis, c)(v2, v4)*va4*np.sin(4*dPhi))

        dbdB = bground(dPhi, B, v2, v3, v4, va2, va4)/B

        #dbdv1 = btilde_func(B, v2, v4)*2*vtilde(1, phis, c)(v1, v2, v3, v4)*np.cos(1*dPhi)/v1


        v2_first_term = (-(2*R2*va2*np.cos(2*dPhi)*np.cos(2*phis)*np.sin(2*c)*(v2+R2*np.cos(2*phis)*np.sin(2*c)/(2*c) + R2*v4*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v2*np.cos(4*phis)*np.sin(4*c)/(4*c)))/(c*(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/2*c +2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))**2))
        v2_second_term = ((2*va2*np.cos(2*dPhi)*(1+R4*np.cos(4*phis)*np.sin(4*c)/(4*c)))/(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)))
        v2_third_term = ((2*va4*np.cos(4*dPhi)*(R2*np.cos(2*phis)*np.sin(2*c)/(2*c) + R6*np.cos(6*phis)*np.sin(6*c)/(6*c)))/(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)))
        v2_fourth_term = -(2*R2*va4*np.cos(4*dPhi)*np.cos(2*phis)*np.sin(2*c)*(v4+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + R4*np.cos(4*phis)*np.sin(4*c)/(4*c)+R6*v2*np.cos(6*phis)*np.sin(6*c)/(6*c)+R8*v4*np.cos(8*phis)*np.sin(8*c)/(8*c)))/(c*(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))**2)
        v2_bonus_term = 1/c*B*R2*np.cos(2*phis)*np.sin(2*c)*(1+2*0*np.cos(dPhi)+2*v3*np.cos(3*dPhi) + (2*va2*np.cos(2*dPhi)*(v2+R2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R2*v4*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v2*np.cos(4*phis)*np.sin(4*c)/(4*c)))/(1+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))+2*va4*np.cos(4*dPhi)*(v4+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*np.cos(4*phis)*np.sin(4*c)/(4*c)+R6*v2*np.cos(6*phis)*np.sin(6*c)/(6*c)+R8*v4*np.cos(8*phis)*np.sin(8*c)/(8*c))/(1+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)))
        
        dbdv2 = btilde_func(B, v2, v4)*(v2_first_term + v2_second_term + v2_third_term + v2_fourth_term) + v2_bonus_term
        #dbdv2 = btilde_func(B, v2, v4)*2*(va2*np.cos(2*dPhi)*(
        #    (1 + np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)
        #    /
        #    (1+2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)
        #            -(v2 + np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + (v4)*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + (v2)*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4 )*(2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2))
        #                /
        #                (1 + 2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)**2 
        #     - va4*np.cos(4*dPhi)*((v4 + np.cos(4*phis)*np.sin(4*c)/(4*c)*R4  )*(2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2))
        #     /
        #     (1 + 2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)**2) + np.pi*(B*c*2/np.pi*2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2)*(1+2*v1*np.cos(1*dPhi) +2*vtilde(2, phis, c)(v1, v2, v3, v4)*va2*np.cos(2*dPhi) +2*v3*np.cos(3*dPhi) + 2*vtilde(4, phis, c)(v1, v2, v3, v4)*va4*np.cos(4*dPhi))

        dbdv3 = btilde_func(B, v2, v4)*vtilde(3, phis, c, R2, R4, R6, R8)(v2, v3, v4)*2*np.cos(3*dPhi)

        v4_first_term = (-(2*R4*va2*np.cos(2*dPhi)*np.cos(4*phis)*np.sin(4*c)*(v2+R2*np.cos(2*phis)*np.sin(2*c)/(2*c) + R2*v4*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v2*np.cos(4*phis)*np.sin(4*c)/(4*c)))/(c*(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/2*c +2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))**2))
        v4_second_term = ((R2*va2*np.cos(2*dPhi)*np.cos(2*phis)*np.sin(2*c)/(2*c))/(c*(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))))
        v4_third_term = ((2*va4*np.cos(4*dPhi)*(1+R8*np.cos(8*phis)*np.sin(8*c)/(8*c)))/(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)))
        v4_fourth_term = -(R4*va4*np.cos(4*dPhi)*np.cos(4*phis)*np.sin(4*c)*(v4+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + R4*np.cos(4*phis)*np.sin(4*c)/(4*c)+R6*v2*np.cos(6*phis)*np.sin(6*c)/(6*c)+R8*v4*np.cos(8*phis)*np.sin(8*c)/(8*c)))/(c*(1 + 2*R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c) + 2*R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))**2)
        v4_bonus_term = 1/(2*c)*B*R4*np.cos(4*phis)*np.sin(4*c)*(1+2*0*np.cos(dPhi)+2*v3*np.cos(3*dPhi) + (2*va2*np.cos(2*dPhi)*(v2+R2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R2*v4*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v2*np.cos(4*phis)*np.sin(4*c)/(4*c)))/(1+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c))+2*va4*np.cos(4*dPhi)*(v4+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*np.cos(4*phis)*np.sin(4*c)/(4*c)+R6*v2*np.cos(6*phis)*np.sin(6*c)/(6*c)+R8*v4*np.cos(8*phis)*np.sin(8*c)/(8*c))/(1+R2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)+R4*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)))
        
        dbdv4 = btilde_func(B, v2, v4)*(v4_first_term + v4_second_term + v4_third_term + v4_fourth_term) + v4_bonus_term

        #dbdv4 = np.pi*btilde_func(B, v2, v4)*2*(va2*np.cos(2*dPhi)*(
        #    (np.cos(2*phis)*np.sin(2*c)/(2*c)*R2)*(1+2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4) 
        #    - (v2 +np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 +v4*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 +v2*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)*(2*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4))
        #    /
        #    (1 + 2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)**2 
        #    + va4*np.cos(4*dPhi)*((1+2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)-(v4+np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)*(2*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4))
        #    /
        #    (1 + 2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)**2) + np.pi*(B*c*2/np.pi*2*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)*(1+2*v1*np.cos(1*dPhi) +2*vtilde(2, phis, c)(v1, v2, v3, v4)*va2*np.cos(2*dPhi) +2*v3*np.cos(3*dPhi) + 2*vtilde(4, phis, c)(v1, v2, v3, v4)*va4*np.cos(4*dPhi))

        dbdva2 = btilde_func(B, v2, v4)*2*vtilde(2, phis, c, R2, R4, R6, R8)( v2, v3, v4)*np.cos(2*dPhi)

        dbdva4 = btilde_func(B, v2, v4)*2*vtilde(4, phis, c, R2, R4, R6, R8)( v2, v3, v4)*np.cos(4*dPhi)

        err = np.sqrt( (dbdB**2 * pcov[0,0]) + (dbdv2**2 * pcov[1,1]) + (dbdv3**2 * pcov[2,2]) + (dbdv4**2 * pcov[3,3]) + (dbdva2**2 * pcov[4,4]) + (dbdva4**2 * pcov[5,5]) +  \
            + 2*(dbdB*dbdv2 * pcov[0,1]) + 2*(dbdB*dbdv3 * pcov[0,2])+2*(dbdB*dbdv4 * pcov[0,3])+2*(dbdB*dbdva2 * pcov[0,4])+2*(dbdB*dbdva4 * pcov[0,5])\
                    + 2*(dbdv2*dbdv3 * pcov[1,2])+2*(dbdv2*dbdv4 * pcov[1,3])+2*(dbdv2*dbdva2 * pcov[1,4])+2*(dbdv2*dbdva4 * pcov[1,5])
                    + 2*(dbdv3*dbdv4 * pcov[2,3])+2*(dbdv3*dbdva2 * pcov[2,4])+2*(dbdv3*dbdva4 * pcov[2,5])
                    + 2*(dbdv4*dbdva2 * pcov[3,4])+2*(dbdv4*dbdva4 * pcov[3,5])
                    + 2*(dbdva2*dbdva4 * pcov[4,5]))
                    
        return err
    return background_err_</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.Fitting.RPF.btilde"><code class="name flex">
<span>def <span class="ident">btilde</span></span>(<span>phis, c, R2, R4, R6, R8)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def btilde( phis, c, R2, R4, R6, R8):
    def btilde_(B, v2, v4):
        return np.pi*B*(1+2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)
    return btilde_</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.Fitting.RPF.simultaneous_err"><code class="name flex">
<span>def <span class="ident">simultaneous_err</span></span>(<span>non_zero_masks, R2, R4, R6, R8, dPhi, B, v2, v3, v4, va2, va4, pcov)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simultaneous_err(non_zero_masks, R2, R4, R6, R8, dPhi, B, v2, v3, v4, va2, va4,  pcov):
    in_plane_err = background_err(0, np.pi/6, R2, R4, R6, R8)
    mid_plane_err = background_err(np.pi/4, np.pi/6, R2, R4, R6, R8)
    out_plane_err = background_err(np.pi/2, np.pi/6, R2, R4, R6, R8)

    if non_zero_masks is None:
        warnings.warn(&#34;non_zero_masks is None, using all data points&#34;)
        non_zero_masks = [np.ones(len(dPhi), dtype=bool)] * 3

    return np.hstack([in_plane_err(dPhi[non_zero_masks[0]], B, v2, v3, v4, va2, va4, pcov), mid_plane_err(dPhi[non_zero_masks[1]], B, v2, v3, v4, va2, va4, pcov), out_plane_err(dPhi[non_zero_masks[2]], B, v2, v3, v4, va2, va4, pcov)])</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.Fitting.RPF.simultaneous_fit"><code class="name flex">
<span>def <span class="ident">simultaneous_fit</span></span>(<span>non_zero_masks, R2, R4, R6, R8, dPhi, B, v2, v3, v4, va2, va4)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simultaneous_fit(non_zero_masks, R2, R4, R6, R8, dPhi, B, v2, v3, v4, va2, va4):
    in_plane_func = background(0, np.pi/6, R2, R4, R6, R8)
    mid_plane_func = background(np.pi/4, np.pi/6, R2, R4, R6, R8)
    out_plane_func = background(np.pi/2, np.pi/6, R2, R4, R6, R8)
    
    if non_zero_masks is None:
        warnings.warn(&#34;non_zero_masks is None, using all data points&#34;)
        non_zero_masks = [np.ones(len(dPhi), dtype=bool)] * 3

    return np.hstack([in_plane_func(dPhi[non_zero_masks[0]], B, v2, v3, v4, va2, va4), mid_plane_func(dPhi[non_zero_masks[1]], B, v2, v3, v4, va2, va4), out_plane_func(dPhi[non_zero_masks[2]], B, v2, v3, v4, va2, va4)])</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.Fitting.RPF.vtilde"><code class="name flex">
<span>def <span class="ident">vtilde</span></span>(<span>n, phis, c, R2, R4, R6, R8)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def vtilde( n, phis, c, R2, R4, R6, R8):
    def vtilde_( v2, v3, v4):
        denom = (1 + 2*v2*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + 2*v4*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4)
        if n&lt;=0 or n&gt;=5: return 0
        if n==1:
            return 0 #v1
        if n==2:
            return (v2 + np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + (v4)*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + (v2)*np.cos(4*phis)*np.sin(4*c)/(4*c)*R4 + (v4)*np.cos(6*phis)*np.sin(6*c)/(6*c)*R6) / denom
        if n==3:
            return v3 
        if n==4:
            return (v4 + np.cos(4*phis)*np.sin(4*c)/(4*c)*R4 + (v2)*np.cos(2*phis)*np.sin(2*c)/(2*c)*R2 + (v2)*np.cos(6*phis)*np.sin(6*c)/(6*c)*R6 + (v4)*np.cos(8*phis)*np.sin(8*c)/(8*c)*R8) / denom
        else:
            return 0
    return vtilde_</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="JetHadronAnalysis.Fitting" href="index.html">JetHadronAnalysis.Fitting</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="JetHadronAnalysis.Fitting.RPF.background" href="#JetHadronAnalysis.Fitting.RPF.background">background</a></code></li>
<li><code><a title="JetHadronAnalysis.Fitting.RPF.background_err" href="#JetHadronAnalysis.Fitting.RPF.background_err">background_err</a></code></li>
<li><code><a title="JetHadronAnalysis.Fitting.RPF.btilde" href="#JetHadronAnalysis.Fitting.RPF.btilde">btilde</a></code></li>
<li><code><a title="JetHadronAnalysis.Fitting.RPF.simultaneous_err" href="#JetHadronAnalysis.Fitting.RPF.simultaneous_err">simultaneous_err</a></code></li>
<li><code><a title="JetHadronAnalysis.Fitting.RPF.simultaneous_fit" href="#JetHadronAnalysis.Fitting.RPF.simultaneous_fit">simultaneous_fit</a></code></li>
<li><code><a title="JetHadronAnalysis.Fitting.RPF.vtilde" href="#JetHadronAnalysis.Fitting.RPF.vtilde">vtilde</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>