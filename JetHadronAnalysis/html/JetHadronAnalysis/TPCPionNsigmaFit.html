<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>JetHadronAnalysis.TPCPionNsigmaFit API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>JetHadronAnalysis.TPCPionNsigmaFit</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
import uncertainties
import sqlite3
from JetHadronAnalysis.Types import AnalysisType, ParticleType, Region, AssociatedHadronMomentumBin
from JetHadronAnalysis.Fitting.TPCnSigmaFitting import piKpInc_generalized_fit, Inc_generalized_fit, piKpInc_generalized_error, piKpInc_generalized_jac, upiKpInc_generalized_fit, gauss, generalized_gauss, ugauss, ugeneralized_gauss

import scipy.optimize as opt
from functools import partial
from typing import List
from ROOT import TH1D #type: ignore
import logging as lg

fitting_logger = lg.getLogger(&#34;fitting&#34;)
fitting_logger.addHandler(lg.FileHandler(&#34;fitting.log&#34;))

class FitTPCPionNsigma:
    def __init__(self, analysisType:AnalysisType, current_region: Region, current_associated_hadron_momentum_bin:AssociatedHadronMomentumBin):

        self.analysisType = analysisType
        self.current_region = current_region
        self.current_associated_hadron_momentum_bin = current_associated_hadron_momentum_bin

        self.initial_parameters = None
        self.bounds = None
        self.fittingFunction = piKpInc_generalized_fit
        self.yieldFittingFunction = Inc_generalized_fit
        self.fittingErrorFunction = piKpInc_generalized_error
        self.pionFittingFunction = gauss
        self.protonFittingFunction = generalized_gauss
        self.kaonFittingFunction = generalized_gauss
        self.databaseConnection = None
        self.initializeDatabase()

    def __del__(self):
        if self.databaseConnection is not None:
            self.databaseConnection.close()

    def setInitialParameters(self, initial_parameters):
        self.initial_parameters = initial_parameters

    def setBounds(self, bounds):
        self.bounds = bounds

    def initializeDefaultParameters(self):
        if self.analysisType==AnalysisType.PP:
            inclusive_p0 = [8,100,12]
            if self.current_region==Region.BACKGROUND:
                inclusive_p0 = [0.8, 10, 1.2]
            inclusive_bounds = [[0,0,0],[100000,100000,100000]]

            generalized_p0 = [0.1, 0.1]
            generalized_bounds = [[-4, -4], [4, 4]]
            if self.current_associated_hadron_momentum_bin.value==1:
                p0 = [2.5, 0, -.5, 0.5, 0.5, 0.5, 100,100, 0.11, 10,100, 10, 0.11,100, 100]+inclusive_p0 + generalized_p0
                if self.current_region==Region.BACKGROUND:
                    p0 = [2.5, 0, -.5, 0.5, 0.5, 0.5, 10,10, 0.11, 1,10, 1, 0.11,10, 10]+inclusive_p0 + generalized_p0
                bounds = [[-6, -0.05, -6, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [6, 0.05, 6, 100.0, 100.0, 100.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1] + generalized_bounds[1]]

            elif self.current_associated_hadron_momentum_bin.value&gt;1 and self.current_associated_hadron_momentum_bin.value&lt;4:
                p0 = [-1.0, 0, -2.5, 0.5, 0.5, 0.5, 100,100, 0.11, 10,100, 10, 0.11,100, 100] + inclusive_p0+ generalized_p0
                if self.current_region==Region.BACKGROUND:
                    p0 = [-1.0, 0, -2.5, 0.5, 0.5, 0.5, 10,10, 0.11, 1,10, 1, 0.11,10, 10] + inclusive_p0+ generalized_p0
                bounds = [[-6, -0.05, -6, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [0, 0.05, 0, 100.0, 100.0, 100.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0]+ generalized_bounds[0], bounds[1]+inclusive_bounds[1] + generalized_bounds[1]]
            else:
                p0 = [-3.5, 0, -2.5, 0.5, 0.5, 0.5, 100,100, 0.11, 10,100, 10, 0.11,100, 100] + inclusive_p0+ generalized_p0
                if self.current_region==Region.BACKGROUND:
                    p0 = [-3.5, 0, -2.5, 0.5, 0.5, 0.5, 10,10, 0.11, 1,10, 1, 0.11,10, 10] + inclusive_p0+ generalized_p0
                bounds = [[-6, -0.05, -6, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [0, 0.05, 0, 100.0, 100.0, 100.0, 100000,100000,10000,100000,100000,100000,10000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1]+ generalized_bounds[1]]
        else:
            inclusive_p0 = [80,1000,120]
            inclusive_bounds = [[0,0,0],[100000,100000,100000]]

            generalized_p0 = [0.5, 0.1]
            generalized_bounds = [[-6, -6], [6, 6]]
            if self.current_associated_hadron_momentum_bin.value==1:
                p0 = [3.0, 0.0, -2.0,  1.5, 1.5, 1.5, 1000,2000, 100, 100,10000, 100, 100,1000, 1000] + inclusive_p0+ generalized_p0
                bounds = [[-5.0, -0.5, -5.0, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [5.0, 0.5, 5.0, 10.0, 10.0, 10.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1]+ generalized_bounds[1]]
            if self.current_associated_hadron_momentum_bin.value&gt;5:
                p0 = [3.0, 0.0, -2.0,  1.5, 1.5, 1.5, 10,20, 1, 1,100, 1, 1,10, 10] + inclusive_p0+ generalized_p0
                bounds = [[-5.0, -0.5, -5.0, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [5.0, 0.5, 5.0, 10.0, 10.0, 10.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1]+ generalized_bounds[1]]
            else:
                p0 = [-1.0, 0.0, 1.0,  1.5, 1.5, 1.5, 100,100, 1.1, 10,100, 10, 1.1,100, 100] + inclusive_p0+ generalized_p0
                bounds = [[-1.5, -0.5, -1.5, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [1.5, 0.5, 1.5, 10.0, 10.0, 10.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0]+generalized_bounds[0], bounds[1]+inclusive_bounds[1]+generalized_bounds[1]]
            
        self.initial_parameters = p0
        self.bounds = bounds

    def initializeDatabase(self):
        &#39;&#39;&#39;
        establish connection to the parameter and particle fraction database named PID.db
        &#39;&#39;&#39;
        fitting_logger.info(&#34;Initializing database&#34;)
        self.databaseConnection = sqlite3.connect(&#34;PID.db&#34;)
        cursor = self.databaseConnection.cursor()
        cursor.execute(&#34;CREATE TABLE IF NOT EXISTS particle_fractions(analysis_type TEXT, region TEXT, momentum_bin INTEGER, pion_fraction REAL, proton_fraction REAL, kaon_fraction REAL, pion_fraction_error REAL, proton_fraction_error REAL, kaon_fraction_error REAL, PRIMARY KEY(analysis_type, region, momentum_bin))&#34;)
        cursor.execute(&#34;CREATE TABLE IF NOT EXISTS fit_parameters(analysis_type TEXT, region TEXT, momentum_bin INTEGER, reduced_chi2 REAL, mu_pion REAL, mu_proton REAL, mu_kaon REAL, sigma_pion REAL, sigma_proton REAL, sigma_kaon REAL, alpha_proton REAL, alpha_kaon REAL, pion_enhanced_pion_fraction REAL, pion_enhanced_proton_fraction REAL, pion_enhanced_kaon_fraction REAL, proton_enhanced_pion_fraction REAL, proton_enhanced_proton_fraction REAL, proton_enhanced_kaon_fraction REAL, kaon_enhanced_pion_fraction REAL, kaon_enhanced_proton_fraction REAL, kaon_enhanced_kaon_fraction REAL, inclusive_pion_fraction REAL, inclusive_proton_fraction REAL, inclusive_kaon_fraction REAL, mu_pion_error REAL, mu_proton_error REAL, mu_kaon_error REAL, sigma_pion_error REAL, sigma_proton_error REAL, sigma_kaon_error REAL, alpha_proton_error REAL, alpha_kaon_error REAL, pion_enhanced_pion_fraction_error REAL, pion_enhanced_proton_fraction_error REAL, pion_enhanced_kaon_fraction_error REAL, proton_enhanced_pion_fraction_error REAL, proton_enhanced_proton_fraction_error REAL, proton_enhanced_kaon_fraction_error REAL, kaon_enhanced_pion_fraction_error REAL, kaon_enhanced_proton_fraction_error REAL, kaon_enhanced_kaon_fraction_error REAL, inclusive_pion_fraction_error REAL, inclusive_proton_fraction_error REAL, inclusive_kaon_fraction_error REAL , PRIMARY KEY(analysis_type, region, momentum_bin))&#34;)
        self.databaseConnection.commit()


    @classmethod
    def prepareData(cls, pionEnhancedTPCnSigma:TH1D, protonEnhancedTPCnSigma:TH1D, kaonEnhancedTPCnSigma:TH1D, inclusiveTPCnSigma:TH1D):
        nbins = pionEnhancedTPCnSigma.GetNbinsX()
        x = np.array([pionEnhancedTPCnSigma.GetBinCenter(i) for i in range(1, nbins+1)])
        y_pi = np.array([pionEnhancedTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
        y_p = np.array([protonEnhancedTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
        y_k = np.array([kaonEnhancedTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
        y_inc = np.array([inclusiveTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
        y = [y_pi, y_p, y_k, y_inc]
        yerr_pi = np.array([pionEnhancedTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
        yerr_p = np.array([protonEnhancedTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
        yerr_k = np.array([kaonEnhancedTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
        yerr_inc = np.array([inclusiveTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
        yerr = [yerr_pi, yerr_p, yerr_k, yerr_inc]

        return x, y, yerr

    def performShapeFit(self, x:np.ndarray, y:List[np.ndarray], yerr:List[np.ndarray]):
        non_zero_masks = [y[i] != 0 for i in range(len(y))]

        y = [y[i][non_zero_masks[i]] for i in range(len(y))]

        yerr = [yerr[i][non_zero_masks[i]] for i in range(len(yerr))]
        #breakpoint()
        final_parameters, covariance = opt.curve_fit(partial(self.fittingFunction, non_zero_masks), x, np.hstack(y), p0=self.initial_parameters, sigma=np.hstack(yerr), bounds=self.bounds,jac=partial(piKpInc_generalized_jac, non_zero_masks), absolute_sigma=True, maxfev=10000000)
        # fitting_logger.info(f&#34;Fit parameters: {final_parameters}&#34;)
        # fitting_logger.info(f&#34;Fit covariance: {covariance}&#34;)
        reduced_chi2 = self.chi2OverNDF(final_parameters, covariance, x, np.hstack(y), np.hstack(yerr), non_zero_masks)
        
        mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak = uncertainties.correlated_values(final_parameters, covariance)
        # put the parameters into a the database 
        if self.databaseConnection is not None:
            cursor = self.databaseConnection.cursor()
            cursor.execute(&#34;REPLACE INTO fit_parameters VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)&#34;, (self.analysisType.name, self.current_region.name, self.current_associated_hadron_momentum_bin.value, reduced_chi2, mupi.n, mup.n, muk.n, sigpi.n, sigp.n, sigk.n, alphap.n, alphak.n, apipi.n, appi.n, akpi.n, apip.n, app.n, akp.n, apik.n, apk.n, akk.n, apiinc.n, apinc.n, akinc.n, mupi.s, mup.s, muk.s, sigpi.s, sigp.s, sigk.s, alphap.s, alphak.s, apipi.s, appi.s, akpi.s, apip.s, app.s, akp.s, apik.s, apk.s, akk.s, apiinc.s, apinc.s, akinc.s))
            self.databaseConnection.commit()
        return final_parameters, covariance
    
    def performYieldFit(self, x:np.ndarray, y:np.ndarray, yerr:np.ndarray, optimal_parameters:np.ndarray):
        non_zero_mask = (y != 0)

        y = y[non_zero_mask]

        yerr = yerr[non_zero_mask] 

        mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak = optimal_parameters
        #breakpoint()
        initialYieldParameters = apinc, apiinc, akinc
        final_parameters, covariance = opt.curve_fit(partial(self.yieldFittingFunction, non_zero_mask, mup, mupi, muk, sigp, sigpi, sigk, alphap, alphak), x, y, p0=initialYieldParameters, sigma=yerr, bounds=(self.bounds[0][-5:-2], self.bounds[1][-5:-2]), absolute_sigma=True, maxfev=10000000)
        # fitting_logger.info(f&#34;Fit parameters: {final_parameters}&#34;)
        # fitting_logger.info(f&#34;Fit covariance: {covariance}&#34;)
        apinc, apiinc, akinc = uncertainties.correlated_values(final_parameters, covariance)
        y_fit = self.yieldFittingFunction(non_zero_mask, mup, mupi, muk, sigp, sigpi, sigk, alphap, alphak,x, *final_parameters)
        reduced_chi2 = np.sum((y-y_fit)**2/yerr**2)/(len(x)-len(final_parameters)) 

        if self.databaseConnection is not None:
            cursor = self.databaseConnection.cursor()
            cursor.execute(&#34;UPDATE fit_parameters SET inclusive_pion_fraction=?, inclusive_proton_fraction=?, inclusive_kaon_fraction=?, inclusive_pion_fraction_error=?, inclusive_proton_fraction_error=?, inclusive_kaon_fraction_error=? WHERE analysis_type=? AND region=? AND momentum_bin=? &#34;, (apiinc.n, apinc.n, akinc.n, apiinc.s, apinc.s, akinc.s, self.analysisType.name, self.current_region.name, self.current_associated_hadron_momentum_bin.value))
            self.databaseConnection.commit()

        return final_parameters, covariance, reduced_chi2

    
    def chi2OverNDF(self, optimal_params, covariance, x, y, yerr, non_zero_masks=None):
        &#39;&#39;&#39;
        Computes the chi2/ndf of the fit
        &#39;&#39;&#39;
        if non_zero_masks is None:
            non_zero_masks = [y[i] != 0 for i in range(len(y))]

            y = np.hstack([y[i][non_zero_masks[i]] for i in range(len(y))])

            yerr = np.hstack([yerr[i][non_zero_masks[i]] for i in range(len(yerr))])
        y_fit = self.fittingFunction(non_zero_masks, x, *optimal_params)
        chi2 = np.sum((y-y_fit)**2/yerr**2)
        ndf = len(x)*4-len(optimal_params) # here we multiply by four because we have four different ys that are fitting simultaneously
        return chi2/ndf
    
    def computeAveragePIDFractions(self, optimal_params, covariance, n_enhanced_associated_hadrons:dict):
        &#39;&#39;&#39;
        Computes PID fractions from the optimal fit params
        &#39;&#39;&#39;
        mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak = uncertainties.correlated_values(optimal_params, covariance)

        int_x = np.linspace(-100, 100, 1000)
        int_y = upiKpInc_generalized_fit(None, int_x, mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak)


        pionEnhNorm  = np.trapz(int_y[:1000], int_x)
        protonEnhNorm = np.trapz(int_y[1000:2000], int_x)
        kaonEnhNorm  = np.trapz(int_y[2000:3000], int_x)
        inclusiveNorm= np.trapz(int_y[3000:], int_x)

        gpp = np.trapz(ugeneralized_gauss(int_x, mup, sigp, app, alphap), int_x)/protonEnhNorm
        gppi = np.trapz(ugauss(int_x, mupi, sigpi, apip), int_x)/protonEnhNorm
        gpk = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akp, alphak), int_x)/protonEnhNorm

        gpip = np.trapz(ugeneralized_gauss(int_x, mup, sigp, appi, alphap), int_x)/pionEnhNorm
        gpipi = np.trapz(ugauss(int_x, mupi, sigpi, apipi), int_x)/pionEnhNorm
        gpik = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akpi, alphak), int_x)/pionEnhNorm

        gkp = np.trapz(ugeneralized_gauss(int_x, mup, sigp, apk, alphap), int_x)/kaonEnhNorm
        gkpi = np.trapz(ugauss(int_x, mupi, sigpi, apik), int_x)/kaonEnhNorm
        gkk = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akk, alphak), int_x)/kaonEnhNorm

        gincp = np.trapz(ugeneralized_gauss(int_x, mup, sigp, apinc, alphap), int_x)/inclusiveNorm
        gincpi = np.trapz(ugauss(int_x, mupi, sigpi, apiinc), int_x)/inclusiveNorm
        ginck = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akinc, alphak), int_x)/inclusiveNorm

        fpp = (gpp/gincp)*(n_enhanced_associated_hadrons[ParticleType.PROTON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fppi = (gppi/gincpi)*(n_enhanced_associated_hadrons[ParticleType.PROTON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fpk = (gpk/ginck)*(n_enhanced_associated_hadrons[ParticleType.PROTON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])

        fpip = (gpip/gincp)*(n_enhanced_associated_hadrons[ParticleType.PION]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fpipi = (gpipi/gincpi)*(n_enhanced_associated_hadrons[ParticleType.PION]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fpik = (gpik/ginck)*(n_enhanced_associated_hadrons[ParticleType.PION]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])

        fkp = (gkp/gincp)*(n_enhanced_associated_hadrons[ParticleType.KAON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fkpi = (gkpi/gincpi)*(n_enhanced_associated_hadrons[ParticleType.KAON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fkk = (gkk/ginck)*(n_enhanced_associated_hadrons[ParticleType.KAON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])

        sum_of_particles_used = n_enhanced_associated_hadrons[ParticleType.PION]+n_enhanced_associated_hadrons[ParticleType.PROTON]+n_enhanced_associated_hadrons[ParticleType.KAON] # Hack to get appropriate fractions, replace once the OTHER bin is added
        pionFraction = gincpi#1/3*(gpipi*pionEnhNorm/(fpipi)+gppi*protonEnhNorm/(fppi)+gkpi*kaonEnhNorm/(fkpi))/sum_of_particles_used#n_enhanced_associated_hadrons[ParticleType.INCLUSIVE]
        protonFraction = gincp#1/3*(gpip*pionEnhNorm/(fpip)+gpp*protonEnhNorm/(fpp)+gkp*kaonEnhNorm/(fkp))/sum_of_particles_used#n_enhanced_associated_hadrons[ParticleType.INCLUSIVE]
        kaonFraction = ginck#1/3*(gpik*pionEnhNorm/(fpik)+gpk*protonEnhNorm/(fpk)+gkk*kaonEnhNorm/(fkk))/sum_of_particles_used#n_enhanced_associated_hadrons[ParticleType.INCLUSIVE]

        # save the particle fractions to the database
        if self.databaseConnection is not None:
            cursor = self.databaseConnection.cursor()
            cursor.execute(&#34;REPLACE INTO particle_fractions VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)&#34;, (self.analysisType.name, self.current_region.name, self.current_associated_hadron_momentum_bin.value, pionFraction.n, protonFraction.n, kaonFraction.n, pionFraction.s, protonFraction.s, kaonFraction.s))
            self.databaseConnection.commit()

        return {ParticleType.PION: pionFraction.n, ParticleType.PROTON:protonFraction.n, ParticleType.KAON:kaonFraction.n}, {ParticleType.PION:pionFraction.s, ParticleType.PROTON:protonFraction.s, ParticleType.KAON:kaonFraction.s}</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma"><code class="flex name class">
<span>class <span class="ident">FitTPCPionNsigma</span></span>
<span>(</span><span>analysisType: <a title="JetHadronAnalysis.Types.AnalysisType" href="Types.html#JetHadronAnalysis.Types.AnalysisType">AnalysisType</a>, current_region: <a title="JetHadronAnalysis.Types.Region" href="Types.html#JetHadronAnalysis.Types.Region">Region</a>, current_associated_hadron_momentum_bin: <a title="JetHadronAnalysis.Types.AssociatedHadronMomentumBin" href="Types.html#JetHadronAnalysis.Types.AssociatedHadronMomentumBin">AssociatedHadronMomentumBin</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FitTPCPionNsigma:
    def __init__(self, analysisType:AnalysisType, current_region: Region, current_associated_hadron_momentum_bin:AssociatedHadronMomentumBin):

        self.analysisType = analysisType
        self.current_region = current_region
        self.current_associated_hadron_momentum_bin = current_associated_hadron_momentum_bin

        self.initial_parameters = None
        self.bounds = None
        self.fittingFunction = piKpInc_generalized_fit
        self.yieldFittingFunction = Inc_generalized_fit
        self.fittingErrorFunction = piKpInc_generalized_error
        self.pionFittingFunction = gauss
        self.protonFittingFunction = generalized_gauss
        self.kaonFittingFunction = generalized_gauss
        self.databaseConnection = None
        self.initializeDatabase()

    def __del__(self):
        if self.databaseConnection is not None:
            self.databaseConnection.close()

    def setInitialParameters(self, initial_parameters):
        self.initial_parameters = initial_parameters

    def setBounds(self, bounds):
        self.bounds = bounds

    def initializeDefaultParameters(self):
        if self.analysisType==AnalysisType.PP:
            inclusive_p0 = [8,100,12]
            if self.current_region==Region.BACKGROUND:
                inclusive_p0 = [0.8, 10, 1.2]
            inclusive_bounds = [[0,0,0],[100000,100000,100000]]

            generalized_p0 = [0.1, 0.1]
            generalized_bounds = [[-4, -4], [4, 4]]
            if self.current_associated_hadron_momentum_bin.value==1:
                p0 = [2.5, 0, -.5, 0.5, 0.5, 0.5, 100,100, 0.11, 10,100, 10, 0.11,100, 100]+inclusive_p0 + generalized_p0
                if self.current_region==Region.BACKGROUND:
                    p0 = [2.5, 0, -.5, 0.5, 0.5, 0.5, 10,10, 0.11, 1,10, 1, 0.11,10, 10]+inclusive_p0 + generalized_p0
                bounds = [[-6, -0.05, -6, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [6, 0.05, 6, 100.0, 100.0, 100.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1] + generalized_bounds[1]]

            elif self.current_associated_hadron_momentum_bin.value&gt;1 and self.current_associated_hadron_momentum_bin.value&lt;4:
                p0 = [-1.0, 0, -2.5, 0.5, 0.5, 0.5, 100,100, 0.11, 10,100, 10, 0.11,100, 100] + inclusive_p0+ generalized_p0
                if self.current_region==Region.BACKGROUND:
                    p0 = [-1.0, 0, -2.5, 0.5, 0.5, 0.5, 10,10, 0.11, 1,10, 1, 0.11,10, 10] + inclusive_p0+ generalized_p0
                bounds = [[-6, -0.05, -6, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [0, 0.05, 0, 100.0, 100.0, 100.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0]+ generalized_bounds[0], bounds[1]+inclusive_bounds[1] + generalized_bounds[1]]
            else:
                p0 = [-3.5, 0, -2.5, 0.5, 0.5, 0.5, 100,100, 0.11, 10,100, 10, 0.11,100, 100] + inclusive_p0+ generalized_p0
                if self.current_region==Region.BACKGROUND:
                    p0 = [-3.5, 0, -2.5, 0.5, 0.5, 0.5, 10,10, 0.11, 1,10, 1, 0.11,10, 10] + inclusive_p0+ generalized_p0
                bounds = [[-6, -0.05, -6, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [0, 0.05, 0, 100.0, 100.0, 100.0, 100000,100000,10000,100000,100000,100000,10000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1]+ generalized_bounds[1]]
        else:
            inclusive_p0 = [80,1000,120]
            inclusive_bounds = [[0,0,0],[100000,100000,100000]]

            generalized_p0 = [0.5, 0.1]
            generalized_bounds = [[-6, -6], [6, 6]]
            if self.current_associated_hadron_momentum_bin.value==1:
                p0 = [3.0, 0.0, -2.0,  1.5, 1.5, 1.5, 1000,2000, 100, 100,10000, 100, 100,1000, 1000] + inclusive_p0+ generalized_p0
                bounds = [[-5.0, -0.5, -5.0, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [5.0, 0.5, 5.0, 10.0, 10.0, 10.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1]+ generalized_bounds[1]]
            if self.current_associated_hadron_momentum_bin.value&gt;5:
                p0 = [3.0, 0.0, -2.0,  1.5, 1.5, 1.5, 10,20, 1, 1,100, 1, 1,10, 10] + inclusive_p0+ generalized_p0
                bounds = [[-5.0, -0.5, -5.0, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [5.0, 0.5, 5.0, 10.0, 10.0, 10.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1]+ generalized_bounds[1]]
            else:
                p0 = [-1.0, 0.0, 1.0,  1.5, 1.5, 1.5, 100,100, 1.1, 10,100, 10, 1.1,100, 100] + inclusive_p0+ generalized_p0
                bounds = [[-1.5, -0.5, -1.5, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [1.5, 0.5, 1.5, 10.0, 10.0, 10.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
                
                bounds = [bounds[0]+inclusive_bounds[0]+generalized_bounds[0], bounds[1]+inclusive_bounds[1]+generalized_bounds[1]]
            
        self.initial_parameters = p0
        self.bounds = bounds

    def initializeDatabase(self):
        &#39;&#39;&#39;
        establish connection to the parameter and particle fraction database named PID.db
        &#39;&#39;&#39;
        fitting_logger.info(&#34;Initializing database&#34;)
        self.databaseConnection = sqlite3.connect(&#34;PID.db&#34;)
        cursor = self.databaseConnection.cursor()
        cursor.execute(&#34;CREATE TABLE IF NOT EXISTS particle_fractions(analysis_type TEXT, region TEXT, momentum_bin INTEGER, pion_fraction REAL, proton_fraction REAL, kaon_fraction REAL, pion_fraction_error REAL, proton_fraction_error REAL, kaon_fraction_error REAL, PRIMARY KEY(analysis_type, region, momentum_bin))&#34;)
        cursor.execute(&#34;CREATE TABLE IF NOT EXISTS fit_parameters(analysis_type TEXT, region TEXT, momentum_bin INTEGER, reduced_chi2 REAL, mu_pion REAL, mu_proton REAL, mu_kaon REAL, sigma_pion REAL, sigma_proton REAL, sigma_kaon REAL, alpha_proton REAL, alpha_kaon REAL, pion_enhanced_pion_fraction REAL, pion_enhanced_proton_fraction REAL, pion_enhanced_kaon_fraction REAL, proton_enhanced_pion_fraction REAL, proton_enhanced_proton_fraction REAL, proton_enhanced_kaon_fraction REAL, kaon_enhanced_pion_fraction REAL, kaon_enhanced_proton_fraction REAL, kaon_enhanced_kaon_fraction REAL, inclusive_pion_fraction REAL, inclusive_proton_fraction REAL, inclusive_kaon_fraction REAL, mu_pion_error REAL, mu_proton_error REAL, mu_kaon_error REAL, sigma_pion_error REAL, sigma_proton_error REAL, sigma_kaon_error REAL, alpha_proton_error REAL, alpha_kaon_error REAL, pion_enhanced_pion_fraction_error REAL, pion_enhanced_proton_fraction_error REAL, pion_enhanced_kaon_fraction_error REAL, proton_enhanced_pion_fraction_error REAL, proton_enhanced_proton_fraction_error REAL, proton_enhanced_kaon_fraction_error REAL, kaon_enhanced_pion_fraction_error REAL, kaon_enhanced_proton_fraction_error REAL, kaon_enhanced_kaon_fraction_error REAL, inclusive_pion_fraction_error REAL, inclusive_proton_fraction_error REAL, inclusive_kaon_fraction_error REAL , PRIMARY KEY(analysis_type, region, momentum_bin))&#34;)
        self.databaseConnection.commit()


    @classmethod
    def prepareData(cls, pionEnhancedTPCnSigma:TH1D, protonEnhancedTPCnSigma:TH1D, kaonEnhancedTPCnSigma:TH1D, inclusiveTPCnSigma:TH1D):
        nbins = pionEnhancedTPCnSigma.GetNbinsX()
        x = np.array([pionEnhancedTPCnSigma.GetBinCenter(i) for i in range(1, nbins+1)])
        y_pi = np.array([pionEnhancedTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
        y_p = np.array([protonEnhancedTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
        y_k = np.array([kaonEnhancedTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
        y_inc = np.array([inclusiveTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
        y = [y_pi, y_p, y_k, y_inc]
        yerr_pi = np.array([pionEnhancedTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
        yerr_p = np.array([protonEnhancedTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
        yerr_k = np.array([kaonEnhancedTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
        yerr_inc = np.array([inclusiveTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
        yerr = [yerr_pi, yerr_p, yerr_k, yerr_inc]

        return x, y, yerr

    def performShapeFit(self, x:np.ndarray, y:List[np.ndarray], yerr:List[np.ndarray]):
        non_zero_masks = [y[i] != 0 for i in range(len(y))]

        y = [y[i][non_zero_masks[i]] for i in range(len(y))]

        yerr = [yerr[i][non_zero_masks[i]] for i in range(len(yerr))]
        #breakpoint()
        final_parameters, covariance = opt.curve_fit(partial(self.fittingFunction, non_zero_masks), x, np.hstack(y), p0=self.initial_parameters, sigma=np.hstack(yerr), bounds=self.bounds,jac=partial(piKpInc_generalized_jac, non_zero_masks), absolute_sigma=True, maxfev=10000000)
        # fitting_logger.info(f&#34;Fit parameters: {final_parameters}&#34;)
        # fitting_logger.info(f&#34;Fit covariance: {covariance}&#34;)
        reduced_chi2 = self.chi2OverNDF(final_parameters, covariance, x, np.hstack(y), np.hstack(yerr), non_zero_masks)
        
        mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak = uncertainties.correlated_values(final_parameters, covariance)
        # put the parameters into a the database 
        if self.databaseConnection is not None:
            cursor = self.databaseConnection.cursor()
            cursor.execute(&#34;REPLACE INTO fit_parameters VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)&#34;, (self.analysisType.name, self.current_region.name, self.current_associated_hadron_momentum_bin.value, reduced_chi2, mupi.n, mup.n, muk.n, sigpi.n, sigp.n, sigk.n, alphap.n, alphak.n, apipi.n, appi.n, akpi.n, apip.n, app.n, akp.n, apik.n, apk.n, akk.n, apiinc.n, apinc.n, akinc.n, mupi.s, mup.s, muk.s, sigpi.s, sigp.s, sigk.s, alphap.s, alphak.s, apipi.s, appi.s, akpi.s, apip.s, app.s, akp.s, apik.s, apk.s, akk.s, apiinc.s, apinc.s, akinc.s))
            self.databaseConnection.commit()
        return final_parameters, covariance
    
    def performYieldFit(self, x:np.ndarray, y:np.ndarray, yerr:np.ndarray, optimal_parameters:np.ndarray):
        non_zero_mask = (y != 0)

        y = y[non_zero_mask]

        yerr = yerr[non_zero_mask] 

        mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak = optimal_parameters
        #breakpoint()
        initialYieldParameters = apinc, apiinc, akinc
        final_parameters, covariance = opt.curve_fit(partial(self.yieldFittingFunction, non_zero_mask, mup, mupi, muk, sigp, sigpi, sigk, alphap, alphak), x, y, p0=initialYieldParameters, sigma=yerr, bounds=(self.bounds[0][-5:-2], self.bounds[1][-5:-2]), absolute_sigma=True, maxfev=10000000)
        # fitting_logger.info(f&#34;Fit parameters: {final_parameters}&#34;)
        # fitting_logger.info(f&#34;Fit covariance: {covariance}&#34;)
        apinc, apiinc, akinc = uncertainties.correlated_values(final_parameters, covariance)
        y_fit = self.yieldFittingFunction(non_zero_mask, mup, mupi, muk, sigp, sigpi, sigk, alphap, alphak,x, *final_parameters)
        reduced_chi2 = np.sum((y-y_fit)**2/yerr**2)/(len(x)-len(final_parameters)) 

        if self.databaseConnection is not None:
            cursor = self.databaseConnection.cursor()
            cursor.execute(&#34;UPDATE fit_parameters SET inclusive_pion_fraction=?, inclusive_proton_fraction=?, inclusive_kaon_fraction=?, inclusive_pion_fraction_error=?, inclusive_proton_fraction_error=?, inclusive_kaon_fraction_error=? WHERE analysis_type=? AND region=? AND momentum_bin=? &#34;, (apiinc.n, apinc.n, akinc.n, apiinc.s, apinc.s, akinc.s, self.analysisType.name, self.current_region.name, self.current_associated_hadron_momentum_bin.value))
            self.databaseConnection.commit()

        return final_parameters, covariance, reduced_chi2

    
    def chi2OverNDF(self, optimal_params, covariance, x, y, yerr, non_zero_masks=None):
        &#39;&#39;&#39;
        Computes the chi2/ndf of the fit
        &#39;&#39;&#39;
        if non_zero_masks is None:
            non_zero_masks = [y[i] != 0 for i in range(len(y))]

            y = np.hstack([y[i][non_zero_masks[i]] for i in range(len(y))])

            yerr = np.hstack([yerr[i][non_zero_masks[i]] for i in range(len(yerr))])
        y_fit = self.fittingFunction(non_zero_masks, x, *optimal_params)
        chi2 = np.sum((y-y_fit)**2/yerr**2)
        ndf = len(x)*4-len(optimal_params) # here we multiply by four because we have four different ys that are fitting simultaneously
        return chi2/ndf
    
    def computeAveragePIDFractions(self, optimal_params, covariance, n_enhanced_associated_hadrons:dict):
        &#39;&#39;&#39;
        Computes PID fractions from the optimal fit params
        &#39;&#39;&#39;
        mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak = uncertainties.correlated_values(optimal_params, covariance)

        int_x = np.linspace(-100, 100, 1000)
        int_y = upiKpInc_generalized_fit(None, int_x, mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak)


        pionEnhNorm  = np.trapz(int_y[:1000], int_x)
        protonEnhNorm = np.trapz(int_y[1000:2000], int_x)
        kaonEnhNorm  = np.trapz(int_y[2000:3000], int_x)
        inclusiveNorm= np.trapz(int_y[3000:], int_x)

        gpp = np.trapz(ugeneralized_gauss(int_x, mup, sigp, app, alphap), int_x)/protonEnhNorm
        gppi = np.trapz(ugauss(int_x, mupi, sigpi, apip), int_x)/protonEnhNorm
        gpk = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akp, alphak), int_x)/protonEnhNorm

        gpip = np.trapz(ugeneralized_gauss(int_x, mup, sigp, appi, alphap), int_x)/pionEnhNorm
        gpipi = np.trapz(ugauss(int_x, mupi, sigpi, apipi), int_x)/pionEnhNorm
        gpik = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akpi, alphak), int_x)/pionEnhNorm

        gkp = np.trapz(ugeneralized_gauss(int_x, mup, sigp, apk, alphap), int_x)/kaonEnhNorm
        gkpi = np.trapz(ugauss(int_x, mupi, sigpi, apik), int_x)/kaonEnhNorm
        gkk = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akk, alphak), int_x)/kaonEnhNorm

        gincp = np.trapz(ugeneralized_gauss(int_x, mup, sigp, apinc, alphap), int_x)/inclusiveNorm
        gincpi = np.trapz(ugauss(int_x, mupi, sigpi, apiinc), int_x)/inclusiveNorm
        ginck = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akinc, alphak), int_x)/inclusiveNorm

        fpp = (gpp/gincp)*(n_enhanced_associated_hadrons[ParticleType.PROTON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fppi = (gppi/gincpi)*(n_enhanced_associated_hadrons[ParticleType.PROTON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fpk = (gpk/ginck)*(n_enhanced_associated_hadrons[ParticleType.PROTON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])

        fpip = (gpip/gincp)*(n_enhanced_associated_hadrons[ParticleType.PION]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fpipi = (gpipi/gincpi)*(n_enhanced_associated_hadrons[ParticleType.PION]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fpik = (gpik/ginck)*(n_enhanced_associated_hadrons[ParticleType.PION]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])

        fkp = (gkp/gincp)*(n_enhanced_associated_hadrons[ParticleType.KAON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fkpi = (gkpi/gincpi)*(n_enhanced_associated_hadrons[ParticleType.KAON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
        fkk = (gkk/ginck)*(n_enhanced_associated_hadrons[ParticleType.KAON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])

        sum_of_particles_used = n_enhanced_associated_hadrons[ParticleType.PION]+n_enhanced_associated_hadrons[ParticleType.PROTON]+n_enhanced_associated_hadrons[ParticleType.KAON] # Hack to get appropriate fractions, replace once the OTHER bin is added
        pionFraction = gincpi#1/3*(gpipi*pionEnhNorm/(fpipi)+gppi*protonEnhNorm/(fppi)+gkpi*kaonEnhNorm/(fkpi))/sum_of_particles_used#n_enhanced_associated_hadrons[ParticleType.INCLUSIVE]
        protonFraction = gincp#1/3*(gpip*pionEnhNorm/(fpip)+gpp*protonEnhNorm/(fpp)+gkp*kaonEnhNorm/(fkp))/sum_of_particles_used#n_enhanced_associated_hadrons[ParticleType.INCLUSIVE]
        kaonFraction = ginck#1/3*(gpik*pionEnhNorm/(fpik)+gpk*protonEnhNorm/(fpk)+gkk*kaonEnhNorm/(fkk))/sum_of_particles_used#n_enhanced_associated_hadrons[ParticleType.INCLUSIVE]

        # save the particle fractions to the database
        if self.databaseConnection is not None:
            cursor = self.databaseConnection.cursor()
            cursor.execute(&#34;REPLACE INTO particle_fractions VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)&#34;, (self.analysisType.name, self.current_region.name, self.current_associated_hadron_momentum_bin.value, pionFraction.n, protonFraction.n, kaonFraction.n, pionFraction.s, protonFraction.s, kaonFraction.s))
            self.databaseConnection.commit()

        return {ParticleType.PION: pionFraction.n, ParticleType.PROTON:protonFraction.n, ParticleType.KAON:kaonFraction.n}, {ParticleType.PION:pionFraction.s, ParticleType.PROTON:protonFraction.s, ParticleType.KAON:kaonFraction.s}</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.prepareData"><code class="name flex">
<span>def <span class="ident">prepareData</span></span>(<span>pionEnhancedTPCnSigma: cppyy.gbl.TH1D, protonEnhancedTPCnSigma: cppyy.gbl.TH1D, kaonEnhancedTPCnSigma: cppyy.gbl.TH1D, inclusiveTPCnSigma: cppyy.gbl.TH1D)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def prepareData(cls, pionEnhancedTPCnSigma:TH1D, protonEnhancedTPCnSigma:TH1D, kaonEnhancedTPCnSigma:TH1D, inclusiveTPCnSigma:TH1D):
    nbins = pionEnhancedTPCnSigma.GetNbinsX()
    x = np.array([pionEnhancedTPCnSigma.GetBinCenter(i) for i in range(1, nbins+1)])
    y_pi = np.array([pionEnhancedTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
    y_p = np.array([protonEnhancedTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
    y_k = np.array([kaonEnhancedTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
    y_inc = np.array([inclusiveTPCnSigma.GetBinContent(i) for i in range(1, nbins+1)])
    y = [y_pi, y_p, y_k, y_inc]
    yerr_pi = np.array([pionEnhancedTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
    yerr_p = np.array([protonEnhancedTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
    yerr_k = np.array([kaonEnhancedTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
    yerr_inc = np.array([inclusiveTPCnSigma.GetBinError(i) for i in range(1, nbins+1)])
    yerr = [yerr_pi, yerr_p, yerr_k, yerr_inc]

    return x, y, yerr</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.chi2OverNDF"><code class="name flex">
<span>def <span class="ident">chi2OverNDF</span></span>(<span>self, optimal_params, covariance, x, y, yerr, non_zero_masks=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the chi2/ndf of the fit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def chi2OverNDF(self, optimal_params, covariance, x, y, yerr, non_zero_masks=None):
    &#39;&#39;&#39;
    Computes the chi2/ndf of the fit
    &#39;&#39;&#39;
    if non_zero_masks is None:
        non_zero_masks = [y[i] != 0 for i in range(len(y))]

        y = np.hstack([y[i][non_zero_masks[i]] for i in range(len(y))])

        yerr = np.hstack([yerr[i][non_zero_masks[i]] for i in range(len(yerr))])
    y_fit = self.fittingFunction(non_zero_masks, x, *optimal_params)
    chi2 = np.sum((y-y_fit)**2/yerr**2)
    ndf = len(x)*4-len(optimal_params) # here we multiply by four because we have four different ys that are fitting simultaneously
    return chi2/ndf</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.computeAveragePIDFractions"><code class="name flex">
<span>def <span class="ident">computeAveragePIDFractions</span></span>(<span>self, optimal_params, covariance, n_enhanced_associated_hadrons: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>Computes PID fractions from the optimal fit params</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def computeAveragePIDFractions(self, optimal_params, covariance, n_enhanced_associated_hadrons:dict):
    &#39;&#39;&#39;
    Computes PID fractions from the optimal fit params
    &#39;&#39;&#39;
    mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak = uncertainties.correlated_values(optimal_params, covariance)

    int_x = np.linspace(-100, 100, 1000)
    int_y = upiKpInc_generalized_fit(None, int_x, mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak)


    pionEnhNorm  = np.trapz(int_y[:1000], int_x)
    protonEnhNorm = np.trapz(int_y[1000:2000], int_x)
    kaonEnhNorm  = np.trapz(int_y[2000:3000], int_x)
    inclusiveNorm= np.trapz(int_y[3000:], int_x)

    gpp = np.trapz(ugeneralized_gauss(int_x, mup, sigp, app, alphap), int_x)/protonEnhNorm
    gppi = np.trapz(ugauss(int_x, mupi, sigpi, apip), int_x)/protonEnhNorm
    gpk = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akp, alphak), int_x)/protonEnhNorm

    gpip = np.trapz(ugeneralized_gauss(int_x, mup, sigp, appi, alphap), int_x)/pionEnhNorm
    gpipi = np.trapz(ugauss(int_x, mupi, sigpi, apipi), int_x)/pionEnhNorm
    gpik = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akpi, alphak), int_x)/pionEnhNorm

    gkp = np.trapz(ugeneralized_gauss(int_x, mup, sigp, apk, alphap), int_x)/kaonEnhNorm
    gkpi = np.trapz(ugauss(int_x, mupi, sigpi, apik), int_x)/kaonEnhNorm
    gkk = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akk, alphak), int_x)/kaonEnhNorm

    gincp = np.trapz(ugeneralized_gauss(int_x, mup, sigp, apinc, alphap), int_x)/inclusiveNorm
    gincpi = np.trapz(ugauss(int_x, mupi, sigpi, apiinc), int_x)/inclusiveNorm
    ginck = np.trapz(ugeneralized_gauss(int_x, muk, sigk, akinc, alphak), int_x)/inclusiveNorm

    fpp = (gpp/gincp)*(n_enhanced_associated_hadrons[ParticleType.PROTON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
    fppi = (gppi/gincpi)*(n_enhanced_associated_hadrons[ParticleType.PROTON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
    fpk = (gpk/ginck)*(n_enhanced_associated_hadrons[ParticleType.PROTON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])

    fpip = (gpip/gincp)*(n_enhanced_associated_hadrons[ParticleType.PION]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
    fpipi = (gpipi/gincpi)*(n_enhanced_associated_hadrons[ParticleType.PION]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
    fpik = (gpik/ginck)*(n_enhanced_associated_hadrons[ParticleType.PION]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])

    fkp = (gkp/gincp)*(n_enhanced_associated_hadrons[ParticleType.KAON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
    fkpi = (gkpi/gincpi)*(n_enhanced_associated_hadrons[ParticleType.KAON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])
    fkk = (gkk/ginck)*(n_enhanced_associated_hadrons[ParticleType.KAON]/n_enhanced_associated_hadrons[ParticleType.INCLUSIVE])

    sum_of_particles_used = n_enhanced_associated_hadrons[ParticleType.PION]+n_enhanced_associated_hadrons[ParticleType.PROTON]+n_enhanced_associated_hadrons[ParticleType.KAON] # Hack to get appropriate fractions, replace once the OTHER bin is added
    pionFraction = gincpi#1/3*(gpipi*pionEnhNorm/(fpipi)+gppi*protonEnhNorm/(fppi)+gkpi*kaonEnhNorm/(fkpi))/sum_of_particles_used#n_enhanced_associated_hadrons[ParticleType.INCLUSIVE]
    protonFraction = gincp#1/3*(gpip*pionEnhNorm/(fpip)+gpp*protonEnhNorm/(fpp)+gkp*kaonEnhNorm/(fkp))/sum_of_particles_used#n_enhanced_associated_hadrons[ParticleType.INCLUSIVE]
    kaonFraction = ginck#1/3*(gpik*pionEnhNorm/(fpik)+gpk*protonEnhNorm/(fpk)+gkk*kaonEnhNorm/(fkk))/sum_of_particles_used#n_enhanced_associated_hadrons[ParticleType.INCLUSIVE]

    # save the particle fractions to the database
    if self.databaseConnection is not None:
        cursor = self.databaseConnection.cursor()
        cursor.execute(&#34;REPLACE INTO particle_fractions VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?)&#34;, (self.analysisType.name, self.current_region.name, self.current_associated_hadron_momentum_bin.value, pionFraction.n, protonFraction.n, kaonFraction.n, pionFraction.s, protonFraction.s, kaonFraction.s))
        self.databaseConnection.commit()

    return {ParticleType.PION: pionFraction.n, ParticleType.PROTON:protonFraction.n, ParticleType.KAON:kaonFraction.n}, {ParticleType.PION:pionFraction.s, ParticleType.PROTON:protonFraction.s, ParticleType.KAON:kaonFraction.s}</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.initializeDatabase"><code class="name flex">
<span>def <span class="ident">initializeDatabase</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>establish connection to the parameter and particle fraction database named PID.db</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initializeDatabase(self):
    &#39;&#39;&#39;
    establish connection to the parameter and particle fraction database named PID.db
    &#39;&#39;&#39;
    fitting_logger.info(&#34;Initializing database&#34;)
    self.databaseConnection = sqlite3.connect(&#34;PID.db&#34;)
    cursor = self.databaseConnection.cursor()
    cursor.execute(&#34;CREATE TABLE IF NOT EXISTS particle_fractions(analysis_type TEXT, region TEXT, momentum_bin INTEGER, pion_fraction REAL, proton_fraction REAL, kaon_fraction REAL, pion_fraction_error REAL, proton_fraction_error REAL, kaon_fraction_error REAL, PRIMARY KEY(analysis_type, region, momentum_bin))&#34;)
    cursor.execute(&#34;CREATE TABLE IF NOT EXISTS fit_parameters(analysis_type TEXT, region TEXT, momentum_bin INTEGER, reduced_chi2 REAL, mu_pion REAL, mu_proton REAL, mu_kaon REAL, sigma_pion REAL, sigma_proton REAL, sigma_kaon REAL, alpha_proton REAL, alpha_kaon REAL, pion_enhanced_pion_fraction REAL, pion_enhanced_proton_fraction REAL, pion_enhanced_kaon_fraction REAL, proton_enhanced_pion_fraction REAL, proton_enhanced_proton_fraction REAL, proton_enhanced_kaon_fraction REAL, kaon_enhanced_pion_fraction REAL, kaon_enhanced_proton_fraction REAL, kaon_enhanced_kaon_fraction REAL, inclusive_pion_fraction REAL, inclusive_proton_fraction REAL, inclusive_kaon_fraction REAL, mu_pion_error REAL, mu_proton_error REAL, mu_kaon_error REAL, sigma_pion_error REAL, sigma_proton_error REAL, sigma_kaon_error REAL, alpha_proton_error REAL, alpha_kaon_error REAL, pion_enhanced_pion_fraction_error REAL, pion_enhanced_proton_fraction_error REAL, pion_enhanced_kaon_fraction_error REAL, proton_enhanced_pion_fraction_error REAL, proton_enhanced_proton_fraction_error REAL, proton_enhanced_kaon_fraction_error REAL, kaon_enhanced_pion_fraction_error REAL, kaon_enhanced_proton_fraction_error REAL, kaon_enhanced_kaon_fraction_error REAL, inclusive_pion_fraction_error REAL, inclusive_proton_fraction_error REAL, inclusive_kaon_fraction_error REAL , PRIMARY KEY(analysis_type, region, momentum_bin))&#34;)
    self.databaseConnection.commit()</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.initializeDefaultParameters"><code class="name flex">
<span>def <span class="ident">initializeDefaultParameters</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initializeDefaultParameters(self):
    if self.analysisType==AnalysisType.PP:
        inclusive_p0 = [8,100,12]
        if self.current_region==Region.BACKGROUND:
            inclusive_p0 = [0.8, 10, 1.2]
        inclusive_bounds = [[0,0,0],[100000,100000,100000]]

        generalized_p0 = [0.1, 0.1]
        generalized_bounds = [[-4, -4], [4, 4]]
        if self.current_associated_hadron_momentum_bin.value==1:
            p0 = [2.5, 0, -.5, 0.5, 0.5, 0.5, 100,100, 0.11, 10,100, 10, 0.11,100, 100]+inclusive_p0 + generalized_p0
            if self.current_region==Region.BACKGROUND:
                p0 = [2.5, 0, -.5, 0.5, 0.5, 0.5, 10,10, 0.11, 1,10, 1, 0.11,10, 10]+inclusive_p0 + generalized_p0
            bounds = [[-6, -0.05, -6, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [6, 0.05, 6, 100.0, 100.0, 100.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
            
            bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1] + generalized_bounds[1]]

        elif self.current_associated_hadron_momentum_bin.value&gt;1 and self.current_associated_hadron_momentum_bin.value&lt;4:
            p0 = [-1.0, 0, -2.5, 0.5, 0.5, 0.5, 100,100, 0.11, 10,100, 10, 0.11,100, 100] + inclusive_p0+ generalized_p0
            if self.current_region==Region.BACKGROUND:
                p0 = [-1.0, 0, -2.5, 0.5, 0.5, 0.5, 10,10, 0.11, 1,10, 1, 0.11,10, 10] + inclusive_p0+ generalized_p0
            bounds = [[-6, -0.05, -6, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [0, 0.05, 0, 100.0, 100.0, 100.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
            
            bounds = [bounds[0]+inclusive_bounds[0]+ generalized_bounds[0], bounds[1]+inclusive_bounds[1] + generalized_bounds[1]]
        else:
            p0 = [-3.5, 0, -2.5, 0.5, 0.5, 0.5, 100,100, 0.11, 10,100, 10, 0.11,100, 100] + inclusive_p0+ generalized_p0
            if self.current_region==Region.BACKGROUND:
                p0 = [-3.5, 0, -2.5, 0.5, 0.5, 0.5, 10,10, 0.11, 1,10, 1, 0.11,10, 10] + inclusive_p0+ generalized_p0
            bounds = [[-6, -0.05, -6, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [0, 0.05, 0, 100.0, 100.0, 100.0, 100000,100000,10000,100000,100000,100000,10000,100000,100000]]
            
            bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1]+ generalized_bounds[1]]
    else:
        inclusive_p0 = [80,1000,120]
        inclusive_bounds = [[0,0,0],[100000,100000,100000]]

        generalized_p0 = [0.5, 0.1]
        generalized_bounds = [[-6, -6], [6, 6]]
        if self.current_associated_hadron_momentum_bin.value==1:
            p0 = [3.0, 0.0, -2.0,  1.5, 1.5, 1.5, 1000,2000, 100, 100,10000, 100, 100,1000, 1000] + inclusive_p0+ generalized_p0
            bounds = [[-5.0, -0.5, -5.0, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [5.0, 0.5, 5.0, 10.0, 10.0, 10.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
            
            bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1]+ generalized_bounds[1]]
        if self.current_associated_hadron_momentum_bin.value&gt;5:
            p0 = [3.0, 0.0, -2.0,  1.5, 1.5, 1.5, 10,20, 1, 1,100, 1, 1,10, 10] + inclusive_p0+ generalized_p0
            bounds = [[-5.0, -0.5, -5.0, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [5.0, 0.5, 5.0, 10.0, 10.0, 10.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
            
            bounds = [bounds[0]+inclusive_bounds[0] + generalized_bounds[0], bounds[1]+inclusive_bounds[1]+ generalized_bounds[1]]
        else:
            p0 = [-1.0, 0.0, 1.0,  1.5, 1.5, 1.5, 100,100, 1.1, 10,100, 10, 1.1,100, 100] + inclusive_p0+ generalized_p0
            bounds = [[-1.5, -0.5, -1.5, 4e-1,4e-1,4e-1, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0], [1.5, 0.5, 1.5, 10.0, 10.0, 10.0, 100000,100000,100000,100000,100000,100000,100000,100000,100000]]
            
            bounds = [bounds[0]+inclusive_bounds[0]+generalized_bounds[0], bounds[1]+inclusive_bounds[1]+generalized_bounds[1]]
        
    self.initial_parameters = p0
    self.bounds = bounds</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.performShapeFit"><code class="name flex">
<span>def <span class="ident">performShapeFit</span></span>(<span>self, x: numpy.ndarray, y: List[numpy.ndarray], yerr: List[numpy.ndarray])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def performShapeFit(self, x:np.ndarray, y:List[np.ndarray], yerr:List[np.ndarray]):
    non_zero_masks = [y[i] != 0 for i in range(len(y))]

    y = [y[i][non_zero_masks[i]] for i in range(len(y))]

    yerr = [yerr[i][non_zero_masks[i]] for i in range(len(yerr))]
    #breakpoint()
    final_parameters, covariance = opt.curve_fit(partial(self.fittingFunction, non_zero_masks), x, np.hstack(y), p0=self.initial_parameters, sigma=np.hstack(yerr), bounds=self.bounds,jac=partial(piKpInc_generalized_jac, non_zero_masks), absolute_sigma=True, maxfev=10000000)
    # fitting_logger.info(f&#34;Fit parameters: {final_parameters}&#34;)
    # fitting_logger.info(f&#34;Fit covariance: {covariance}&#34;)
    reduced_chi2 = self.chi2OverNDF(final_parameters, covariance, x, np.hstack(y), np.hstack(yerr), non_zero_masks)
    
    mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak = uncertainties.correlated_values(final_parameters, covariance)
    # put the parameters into a the database 
    if self.databaseConnection is not None:
        cursor = self.databaseConnection.cursor()
        cursor.execute(&#34;REPLACE INTO fit_parameters VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)&#34;, (self.analysisType.name, self.current_region.name, self.current_associated_hadron_momentum_bin.value, reduced_chi2, mupi.n, mup.n, muk.n, sigpi.n, sigp.n, sigk.n, alphap.n, alphak.n, apipi.n, appi.n, akpi.n, apip.n, app.n, akp.n, apik.n, apk.n, akk.n, apiinc.n, apinc.n, akinc.n, mupi.s, mup.s, muk.s, sigpi.s, sigp.s, sigk.s, alphap.s, alphak.s, apipi.s, appi.s, akpi.s, apip.s, app.s, akp.s, apik.s, apk.s, akk.s, apiinc.s, apinc.s, akinc.s))
        self.databaseConnection.commit()
    return final_parameters, covariance</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.performYieldFit"><code class="name flex">
<span>def <span class="ident">performYieldFit</span></span>(<span>self, x: numpy.ndarray, y: numpy.ndarray, yerr: numpy.ndarray, optimal_parameters: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def performYieldFit(self, x:np.ndarray, y:np.ndarray, yerr:np.ndarray, optimal_parameters:np.ndarray):
    non_zero_mask = (y != 0)

    y = y[non_zero_mask]

    yerr = yerr[non_zero_mask] 

    mup, mupi, muk, sigp, sigpi, sigk, app, apip, akp, appi, apipi, akpi, apk, apik, akk, apinc, apiinc, akinc, alphap, alphak = optimal_parameters
    #breakpoint()
    initialYieldParameters = apinc, apiinc, akinc
    final_parameters, covariance = opt.curve_fit(partial(self.yieldFittingFunction, non_zero_mask, mup, mupi, muk, sigp, sigpi, sigk, alphap, alphak), x, y, p0=initialYieldParameters, sigma=yerr, bounds=(self.bounds[0][-5:-2], self.bounds[1][-5:-2]), absolute_sigma=True, maxfev=10000000)
    # fitting_logger.info(f&#34;Fit parameters: {final_parameters}&#34;)
    # fitting_logger.info(f&#34;Fit covariance: {covariance}&#34;)
    apinc, apiinc, akinc = uncertainties.correlated_values(final_parameters, covariance)
    y_fit = self.yieldFittingFunction(non_zero_mask, mup, mupi, muk, sigp, sigpi, sigk, alphap, alphak,x, *final_parameters)
    reduced_chi2 = np.sum((y-y_fit)**2/yerr**2)/(len(x)-len(final_parameters)) 

    if self.databaseConnection is not None:
        cursor = self.databaseConnection.cursor()
        cursor.execute(&#34;UPDATE fit_parameters SET inclusive_pion_fraction=?, inclusive_proton_fraction=?, inclusive_kaon_fraction=?, inclusive_pion_fraction_error=?, inclusive_proton_fraction_error=?, inclusive_kaon_fraction_error=? WHERE analysis_type=? AND region=? AND momentum_bin=? &#34;, (apiinc.n, apinc.n, akinc.n, apiinc.s, apinc.s, akinc.s, self.analysisType.name, self.current_region.name, self.current_associated_hadron_momentum_bin.value))
        self.databaseConnection.commit()

    return final_parameters, covariance, reduced_chi2</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.setBounds"><code class="name flex">
<span>def <span class="ident">setBounds</span></span>(<span>self, bounds)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setBounds(self, bounds):
    self.bounds = bounds</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.setInitialParameters"><code class="name flex">
<span>def <span class="ident">setInitialParameters</span></span>(<span>self, initial_parameters)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def setInitialParameters(self, initial_parameters):
    self.initial_parameters = initial_parameters</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="JetHadronAnalysis" href="index.html">JetHadronAnalysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma" href="#JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma">FitTPCPionNsigma</a></code></h4>
<ul class="">
<li><code><a title="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.chi2OverNDF" href="#JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.chi2OverNDF">chi2OverNDF</a></code></li>
<li><code><a title="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.computeAveragePIDFractions" href="#JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.computeAveragePIDFractions">computeAveragePIDFractions</a></code></li>
<li><code><a title="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.initializeDatabase" href="#JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.initializeDatabase">initializeDatabase</a></code></li>
<li><code><a title="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.initializeDefaultParameters" href="#JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.initializeDefaultParameters">initializeDefaultParameters</a></code></li>
<li><code><a title="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.performShapeFit" href="#JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.performShapeFit">performShapeFit</a></code></li>
<li><code><a title="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.performYieldFit" href="#JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.performYieldFit">performYieldFit</a></code></li>
<li><code><a title="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.prepareData" href="#JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.prepareData">prepareData</a></code></li>
<li><code><a title="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.setBounds" href="#JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.setBounds">setBounds</a></code></li>
<li><code><a title="JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.setInitialParameters" href="#JetHadronAnalysis.TPCPionNsigmaFit.FitTPCPionNsigma.setInitialParameters">setInitialParameters</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>