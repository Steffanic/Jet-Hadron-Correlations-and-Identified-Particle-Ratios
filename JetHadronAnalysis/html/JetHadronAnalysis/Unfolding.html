<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>JetHadronAnalysis.Unfolding API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>JetHadronAnalysis.Unfolding</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import numpy as np
from pyunfold import iterative_unfold
from typing import Optional

class ResponseMatrix:
    def __init__(self):
        self.matrix = np.zeros((4,3)) # pi, p, k, trash
        self.error = np.zeros((4,3)) # pi, p, k, trash
        # self.root_response = None#RooUnfoldResponse(4, 0.0, 3.0, 3, 0.0, 2.0) # Int_t         nm, Double_t    mlo, Double_t   mhi, Int_t      nt, Double_t    tlo, Double_t   thi, const char *       name = 0, const char *  title = 0 

    def buildResponseMatrix(self, pionEffect:dict, protonEffect:dict, kaonEffect:dict, trashEffect:dict, normalize:bool=False, use_ROOT:bool=False):
        &#39;&#39;&#39;
        The steps to generating the response matrix are as follows:
        1. Generate the Pion-, Proton-, Kaon-, and Trash- TPC Pion NSigma histograms
        2. Fit them with the appropriate functions\
        3. Integrate the functions from -inf to inf to get the total number of particles in each sample of each type (pi, p, k, trash)
        4. Divide the number of particles in each sample by the total number of particles in each sample to get the probability of each particle being a pion, proton, kaon, or trash
        5. Fill the response matrix with the probabilities
        6. Normalize the response matrix
        7. Profit (hopefully)

        This function should only be responsible for taking the probabilities and filling the response matrix
        It should take the effect probabilities as an argument, e.g. pionEffect, which is a dictionary of the form:
        {
            &#39;pionCause&#39;: probability of a pion being reconstructed as a pion,
            &#39;protonCause&#39;: probability of a proton being reconstructed as a pion,
            &#39;kaonCause&#39;: probability of a kaon being reconstructed as a pion,
            &#39;trashCause&#39;: probability of a trash particle being reconstructed as a pion
        }
        etc. for the other effect probabilities
        &#39;&#39;&#39;
        # Fill the response matrix
        self.matrix[0][0] = pionEffect[&#39;pionCause&#39;]
        self.matrix[0][1] = pionEffect[&#39;protonCause&#39;]
        self.matrix[0][2] = pionEffect[&#39;kaonCause&#39;]


        self.matrix[1][0] = protonEffect[&#39;pionCause&#39;]
        self.matrix[1][1] = protonEffect[&#39;protonCause&#39;]
        self.matrix[1][2] = protonEffect[&#39;kaonCause&#39;]


        self.matrix[2][0] = kaonEffect[&#39;pionCause&#39;]
        self.matrix[2][1] = kaonEffect[&#39;protonCause&#39;]
        self.matrix[2][2] = kaonEffect[&#39;kaonCause&#39;]


        self.matrix[3][0] = trashEffect[&#39;pionCause&#39;]
        self.matrix[3][1] = trashEffect[&#39;protonCause&#39;]
        self.matrix[3][2] = trashEffect[&#39;kaonCause&#39;]


        if normalize:    
            # Normalize the response matrix
            self.matrix = self.matrix / np.sum(self.matrix, axis=0)

#         if use_ROOT:
#             resp_TH2 = TH2D(&#34;resp_TH2&#34;, &#34;resp_TH2&#34;, 4, 0.0, 3.0, 3, 0.0, 2.0)
#             resp_TH2.SetBinContent(1, 1, self.matrix[0][0])
#             resp_TH2.SetBinContent(1, 2, self.matrix[0][1])
#             resp_TH2.SetBinContent(1, 3, self.matrix[0][2])
# 
#             resp_TH2.SetBinContent(2, 1, self.matrix[1][0])
#             resp_TH2.SetBinContent(2, 2, self.matrix[1][1])
#             resp_TH2.SetBinContent(2, 3, self.matrix[1][2])
# 
#             resp_TH2.SetBinContent(3, 1, self.matrix[2][0])
#             resp_TH2.SetBinContent(3, 2, self.matrix[2][1])
#             resp_TH2.SetBinContent(3, 3, self.matrix[2][2])
# 
#             resp_TH2.SetBinContent(4, 1, self.matrix[3][0])
#             resp_TH2.SetBinContent(4, 2, self.matrix[3][1])
#             resp_TH2.SetBinContent(4, 3, self.matrix[3][2])
# 
#             self.root_response = RooUnfoldResponse(0,0,resp_TH2)
#             breakpoint()
            
            

    def buildResponseMatrixError(self, pionEffectError:dict, protonEffectError:dict, kaonEffectError:dict, trashEffectError:dict):
        &#39;&#39;&#39;
        This function should take the effect errors as an argument, e.g. pionEffectError, which is a dictionary of the form:
        {
            &#39;pionCauseError&#39;: uncertainty of a pion being reconstructed as a pion,
            &#39;protonCauseError&#39;: uncertainty of a proton being reconstructed as a pion,
            &#39;kaonCauseError&#39;: uncertainty of a kaon being reconstructed as a pion,
            &#39;trashCauseError&#39;: uncertainty of a trash particle being reconstructed as a pion
        }
        etc. for the other effect errors
        &#39;&#39;&#39;
        # Fill the response matrix error
        self.error[0][0] = pionEffectError[&#39;pionCauseError&#39;]
        self.error[0][1] = pionEffectError[&#39;protonCauseError&#39;]
        self.error[0][2] = pionEffectError[&#39;kaonCauseError&#39;]

        self.error[1][0] = protonEffectError[&#39;pionCauseError&#39;]
        self.error[1][1] = protonEffectError[&#39;protonCauseError&#39;]
        self.error[1][2] = protonEffectError[&#39;kaonCauseError&#39;]

        self.error[2][0] = kaonEffectError[&#39;pionCauseError&#39;]
        self.error[2][1] = kaonEffectError[&#39;protonCauseError&#39;]
        self.error[2][2] = kaonEffectError[&#39;kaonCauseError&#39;]

        self.error[3][0] = trashEffectError[&#39;pionCauseError&#39;]
        self.error[3][1] = trashEffectError[&#39;protonCauseError&#39;]
        self.error[3][2] = trashEffectError[&#39;kaonCauseError&#39;]

    def getResponseMatrix(self):
        return self.matrix
    
    def getResponseMatrixError(self):
        return self.error

class Unfolder:
    def __init__(self, response_matrix: ResponseMatrix):
        self.response_matrix = response_matrix
        self.unfolding_matrix = None # to be filled by the unfolding algorithm

    def unfold(self, data: np.ndarray, data_errors: np.ndarray, efficiency: Optional[np.ndarray]=None, efficiency_errors: Optional[np.ndarray]=None, test_statistic: str=&#39;ks&#39;, test_statistic_stopping: float=0.01):
        &#39;&#39;&#39;
        This function should take the data and return the unfolded data
        &#39;&#39;&#39;
        if efficiency is None and efficiency_errors is None:
            efficiency = np.ones(data.shape[0]-1)
            efficiency_errors = np.zeros(data.shape[0]-1)
        unfolded_data = iterative_unfold(
            data=data, data_err=data_errors, response=self.response_matrix.getResponseMatrix(), response_err=self.response_matrix.getResponseMatrixError(), efficiencies=efficiency, efficiencies_err=efficiency_errors, ts=test_statistic, ts_stopping=test_statistic_stopping, cov_type=&#39;poisson&#39;, max_iter=100)
        self.unfolding_matrix = unfolded_data[&#39;unfolding_matrix&#39;]
        return unfolded_data

    def refold(self, unfolded_data: np.ndarray):
        &#39;&#39;&#39;
        This function should take the unfolded data and return the refolded data
        &#39;&#39;&#39;
        if self.unfolding_matrix is None:
            raise ValueError(&#34;Unfolding matrix is not set. Please run unfold() first.&#34;)
        refolded_data = np.matmul(self.unfolding_matrix, unfolded_data)
        return refolded_data</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="JetHadronAnalysis.Unfolding.ResponseMatrix"><code class="flex name class">
<span>class <span class="ident">ResponseMatrix</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ResponseMatrix:
    def __init__(self):
        self.matrix = np.zeros((4,3)) # pi, p, k, trash
        self.error = np.zeros((4,3)) # pi, p, k, trash
        # self.root_response = None#RooUnfoldResponse(4, 0.0, 3.0, 3, 0.0, 2.0) # Int_t         nm, Double_t    mlo, Double_t   mhi, Int_t      nt, Double_t    tlo, Double_t   thi, const char *       name = 0, const char *  title = 0 

    def buildResponseMatrix(self, pionEffect:dict, protonEffect:dict, kaonEffect:dict, trashEffect:dict, normalize:bool=False, use_ROOT:bool=False):
        &#39;&#39;&#39;
        The steps to generating the response matrix are as follows:
        1. Generate the Pion-, Proton-, Kaon-, and Trash- TPC Pion NSigma histograms
        2. Fit them with the appropriate functions\
        3. Integrate the functions from -inf to inf to get the total number of particles in each sample of each type (pi, p, k, trash)
        4. Divide the number of particles in each sample by the total number of particles in each sample to get the probability of each particle being a pion, proton, kaon, or trash
        5. Fill the response matrix with the probabilities
        6. Normalize the response matrix
        7. Profit (hopefully)

        This function should only be responsible for taking the probabilities and filling the response matrix
        It should take the effect probabilities as an argument, e.g. pionEffect, which is a dictionary of the form:
        {
            &#39;pionCause&#39;: probability of a pion being reconstructed as a pion,
            &#39;protonCause&#39;: probability of a proton being reconstructed as a pion,
            &#39;kaonCause&#39;: probability of a kaon being reconstructed as a pion,
            &#39;trashCause&#39;: probability of a trash particle being reconstructed as a pion
        }
        etc. for the other effect probabilities
        &#39;&#39;&#39;
        # Fill the response matrix
        self.matrix[0][0] = pionEffect[&#39;pionCause&#39;]
        self.matrix[0][1] = pionEffect[&#39;protonCause&#39;]
        self.matrix[0][2] = pionEffect[&#39;kaonCause&#39;]


        self.matrix[1][0] = protonEffect[&#39;pionCause&#39;]
        self.matrix[1][1] = protonEffect[&#39;protonCause&#39;]
        self.matrix[1][2] = protonEffect[&#39;kaonCause&#39;]


        self.matrix[2][0] = kaonEffect[&#39;pionCause&#39;]
        self.matrix[2][1] = kaonEffect[&#39;protonCause&#39;]
        self.matrix[2][2] = kaonEffect[&#39;kaonCause&#39;]


        self.matrix[3][0] = trashEffect[&#39;pionCause&#39;]
        self.matrix[3][1] = trashEffect[&#39;protonCause&#39;]
        self.matrix[3][2] = trashEffect[&#39;kaonCause&#39;]


        if normalize:    
            # Normalize the response matrix
            self.matrix = self.matrix / np.sum(self.matrix, axis=0)

#         if use_ROOT:
#             resp_TH2 = TH2D(&#34;resp_TH2&#34;, &#34;resp_TH2&#34;, 4, 0.0, 3.0, 3, 0.0, 2.0)
#             resp_TH2.SetBinContent(1, 1, self.matrix[0][0])
#             resp_TH2.SetBinContent(1, 2, self.matrix[0][1])
#             resp_TH2.SetBinContent(1, 3, self.matrix[0][2])
# 
#             resp_TH2.SetBinContent(2, 1, self.matrix[1][0])
#             resp_TH2.SetBinContent(2, 2, self.matrix[1][1])
#             resp_TH2.SetBinContent(2, 3, self.matrix[1][2])
# 
#             resp_TH2.SetBinContent(3, 1, self.matrix[2][0])
#             resp_TH2.SetBinContent(3, 2, self.matrix[2][1])
#             resp_TH2.SetBinContent(3, 3, self.matrix[2][2])
# 
#             resp_TH2.SetBinContent(4, 1, self.matrix[3][0])
#             resp_TH2.SetBinContent(4, 2, self.matrix[3][1])
#             resp_TH2.SetBinContent(4, 3, self.matrix[3][2])
# 
#             self.root_response = RooUnfoldResponse(0,0,resp_TH2)
#             breakpoint()
            
            

    def buildResponseMatrixError(self, pionEffectError:dict, protonEffectError:dict, kaonEffectError:dict, trashEffectError:dict):
        &#39;&#39;&#39;
        This function should take the effect errors as an argument, e.g. pionEffectError, which is a dictionary of the form:
        {
            &#39;pionCauseError&#39;: uncertainty of a pion being reconstructed as a pion,
            &#39;protonCauseError&#39;: uncertainty of a proton being reconstructed as a pion,
            &#39;kaonCauseError&#39;: uncertainty of a kaon being reconstructed as a pion,
            &#39;trashCauseError&#39;: uncertainty of a trash particle being reconstructed as a pion
        }
        etc. for the other effect errors
        &#39;&#39;&#39;
        # Fill the response matrix error
        self.error[0][0] = pionEffectError[&#39;pionCauseError&#39;]
        self.error[0][1] = pionEffectError[&#39;protonCauseError&#39;]
        self.error[0][2] = pionEffectError[&#39;kaonCauseError&#39;]

        self.error[1][0] = protonEffectError[&#39;pionCauseError&#39;]
        self.error[1][1] = protonEffectError[&#39;protonCauseError&#39;]
        self.error[1][2] = protonEffectError[&#39;kaonCauseError&#39;]

        self.error[2][0] = kaonEffectError[&#39;pionCauseError&#39;]
        self.error[2][1] = kaonEffectError[&#39;protonCauseError&#39;]
        self.error[2][2] = kaonEffectError[&#39;kaonCauseError&#39;]

        self.error[3][0] = trashEffectError[&#39;pionCauseError&#39;]
        self.error[3][1] = trashEffectError[&#39;protonCauseError&#39;]
        self.error[3][2] = trashEffectError[&#39;kaonCauseError&#39;]

    def getResponseMatrix(self):
        return self.matrix
    
    def getResponseMatrixError(self):
        return self.error</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="JetHadronAnalysis.Unfolding.ResponseMatrix.buildResponseMatrix"><code class="name flex">
<span>def <span class="ident">buildResponseMatrix</span></span>(<span>self, pionEffect: dict, protonEffect: dict, kaonEffect: dict, trashEffect: dict, normalize: bool = False, use_ROOT: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>The steps to generating the response matrix are as follows:
1. Generate the Pion-, Proton-, Kaon-, and Trash- TPC Pion NSigma histograms
2. Fit them with the appropriate functions
3. Integrate the functions from -inf to inf to get the total number of particles in each sample of each type (pi, p, k, trash)
4. Divide the number of particles in each sample by the total number of particles in each sample to get the probability of each particle being a pion, proton, kaon, or trash
5. Fill the response matrix with the probabilities
6. Normalize the response matrix
7. Profit (hopefully)</p>
<p>This function should only be responsible for taking the probabilities and filling the response matrix
It should take the effect probabilities as an argument, e.g. pionEffect, which is a dictionary of the form:
{
'pionCause': probability of a pion being reconstructed as a pion,
'protonCause': probability of a proton being reconstructed as a pion,
'kaonCause': probability of a kaon being reconstructed as a pion,
'trashCause': probability of a trash particle being reconstructed as a pion
}
etc. for the other effect probabilities</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildResponseMatrix(self, pionEffect:dict, protonEffect:dict, kaonEffect:dict, trashEffect:dict, normalize:bool=False, use_ROOT:bool=False):
    &#39;&#39;&#39;
    The steps to generating the response matrix are as follows:
    1. Generate the Pion-, Proton-, Kaon-, and Trash- TPC Pion NSigma histograms
    2. Fit them with the appropriate functions\
    3. Integrate the functions from -inf to inf to get the total number of particles in each sample of each type (pi, p, k, trash)
    4. Divide the number of particles in each sample by the total number of particles in each sample to get the probability of each particle being a pion, proton, kaon, or trash
    5. Fill the response matrix with the probabilities
    6. Normalize the response matrix
    7. Profit (hopefully)

    This function should only be responsible for taking the probabilities and filling the response matrix
    It should take the effect probabilities as an argument, e.g. pionEffect, which is a dictionary of the form:
    {
        &#39;pionCause&#39;: probability of a pion being reconstructed as a pion,
        &#39;protonCause&#39;: probability of a proton being reconstructed as a pion,
        &#39;kaonCause&#39;: probability of a kaon being reconstructed as a pion,
        &#39;trashCause&#39;: probability of a trash particle being reconstructed as a pion
    }
    etc. for the other effect probabilities
    &#39;&#39;&#39;
    # Fill the response matrix
    self.matrix[0][0] = pionEffect[&#39;pionCause&#39;]
    self.matrix[0][1] = pionEffect[&#39;protonCause&#39;]
    self.matrix[0][2] = pionEffect[&#39;kaonCause&#39;]


    self.matrix[1][0] = protonEffect[&#39;pionCause&#39;]
    self.matrix[1][1] = protonEffect[&#39;protonCause&#39;]
    self.matrix[1][2] = protonEffect[&#39;kaonCause&#39;]


    self.matrix[2][0] = kaonEffect[&#39;pionCause&#39;]
    self.matrix[2][1] = kaonEffect[&#39;protonCause&#39;]
    self.matrix[2][2] = kaonEffect[&#39;kaonCause&#39;]


    self.matrix[3][0] = trashEffect[&#39;pionCause&#39;]
    self.matrix[3][1] = trashEffect[&#39;protonCause&#39;]
    self.matrix[3][2] = trashEffect[&#39;kaonCause&#39;]


    if normalize:    
        # Normalize the response matrix
        self.matrix = self.matrix / np.sum(self.matrix, axis=0)</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.Unfolding.ResponseMatrix.buildResponseMatrixError"><code class="name flex">
<span>def <span class="ident">buildResponseMatrixError</span></span>(<span>self, pionEffectError: dict, protonEffectError: dict, kaonEffectError: dict, trashEffectError: dict)</span>
</code></dt>
<dd>
<div class="desc"><p>This function should take the effect errors as an argument, e.g. pionEffectError, which is a dictionary of the form:
{
'pionCauseError': uncertainty of a pion being reconstructed as a pion,
'protonCauseError': uncertainty of a proton being reconstructed as a pion,
'kaonCauseError': uncertainty of a kaon being reconstructed as a pion,
'trashCauseError': uncertainty of a trash particle being reconstructed as a pion
}
etc. for the other effect errors</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def buildResponseMatrixError(self, pionEffectError:dict, protonEffectError:dict, kaonEffectError:dict, trashEffectError:dict):
    &#39;&#39;&#39;
    This function should take the effect errors as an argument, e.g. pionEffectError, which is a dictionary of the form:
    {
        &#39;pionCauseError&#39;: uncertainty of a pion being reconstructed as a pion,
        &#39;protonCauseError&#39;: uncertainty of a proton being reconstructed as a pion,
        &#39;kaonCauseError&#39;: uncertainty of a kaon being reconstructed as a pion,
        &#39;trashCauseError&#39;: uncertainty of a trash particle being reconstructed as a pion
    }
    etc. for the other effect errors
    &#39;&#39;&#39;
    # Fill the response matrix error
    self.error[0][0] = pionEffectError[&#39;pionCauseError&#39;]
    self.error[0][1] = pionEffectError[&#39;protonCauseError&#39;]
    self.error[0][2] = pionEffectError[&#39;kaonCauseError&#39;]

    self.error[1][0] = protonEffectError[&#39;pionCauseError&#39;]
    self.error[1][1] = protonEffectError[&#39;protonCauseError&#39;]
    self.error[1][2] = protonEffectError[&#39;kaonCauseError&#39;]

    self.error[2][0] = kaonEffectError[&#39;pionCauseError&#39;]
    self.error[2][1] = kaonEffectError[&#39;protonCauseError&#39;]
    self.error[2][2] = kaonEffectError[&#39;kaonCauseError&#39;]

    self.error[3][0] = trashEffectError[&#39;pionCauseError&#39;]
    self.error[3][1] = trashEffectError[&#39;protonCauseError&#39;]
    self.error[3][2] = trashEffectError[&#39;kaonCauseError&#39;]</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.Unfolding.ResponseMatrix.getResponseMatrix"><code class="name flex">
<span>def <span class="ident">getResponseMatrix</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getResponseMatrix(self):
    return self.matrix</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.Unfolding.ResponseMatrix.getResponseMatrixError"><code class="name flex">
<span>def <span class="ident">getResponseMatrixError</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def getResponseMatrixError(self):
    return self.error</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="JetHadronAnalysis.Unfolding.Unfolder"><code class="flex name class">
<span>class <span class="ident">Unfolder</span></span>
<span>(</span><span>response_matrix: <a title="JetHadronAnalysis.Unfolding.ResponseMatrix" href="#JetHadronAnalysis.Unfolding.ResponseMatrix">ResponseMatrix</a>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Unfolder:
    def __init__(self, response_matrix: ResponseMatrix):
        self.response_matrix = response_matrix
        self.unfolding_matrix = None # to be filled by the unfolding algorithm

    def unfold(self, data: np.ndarray, data_errors: np.ndarray, efficiency: Optional[np.ndarray]=None, efficiency_errors: Optional[np.ndarray]=None, test_statistic: str=&#39;ks&#39;, test_statistic_stopping: float=0.01):
        &#39;&#39;&#39;
        This function should take the data and return the unfolded data
        &#39;&#39;&#39;
        if efficiency is None and efficiency_errors is None:
            efficiency = np.ones(data.shape[0]-1)
            efficiency_errors = np.zeros(data.shape[0]-1)
        unfolded_data = iterative_unfold(
            data=data, data_err=data_errors, response=self.response_matrix.getResponseMatrix(), response_err=self.response_matrix.getResponseMatrixError(), efficiencies=efficiency, efficiencies_err=efficiency_errors, ts=test_statistic, ts_stopping=test_statistic_stopping, cov_type=&#39;poisson&#39;, max_iter=100)
        self.unfolding_matrix = unfolded_data[&#39;unfolding_matrix&#39;]
        return unfolded_data

    def refold(self, unfolded_data: np.ndarray):
        &#39;&#39;&#39;
        This function should take the unfolded data and return the refolded data
        &#39;&#39;&#39;
        if self.unfolding_matrix is None:
            raise ValueError(&#34;Unfolding matrix is not set. Please run unfold() first.&#34;)
        refolded_data = np.matmul(self.unfolding_matrix, unfolded_data)
        return refolded_data</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="JetHadronAnalysis.Unfolding.Unfolder.refold"><code class="name flex">
<span>def <span class="ident">refold</span></span>(<span>self, unfolded_data: numpy.ndarray)</span>
</code></dt>
<dd>
<div class="desc"><p>This function should take the unfolded data and return the refolded data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def refold(self, unfolded_data: np.ndarray):
    &#39;&#39;&#39;
    This function should take the unfolded data and return the refolded data
    &#39;&#39;&#39;
    if self.unfolding_matrix is None:
        raise ValueError(&#34;Unfolding matrix is not set. Please run unfold() first.&#34;)
    refolded_data = np.matmul(self.unfolding_matrix, unfolded_data)
    return refolded_data</code></pre>
</details>
</dd>
<dt id="JetHadronAnalysis.Unfolding.Unfolder.unfold"><code class="name flex">
<span>def <span class="ident">unfold</span></span>(<span>self, data: numpy.ndarray, data_errors: numpy.ndarray, efficiency: Optional[numpy.ndarray] = None, efficiency_errors: Optional[numpy.ndarray] = None, test_statistic: str = 'ks', test_statistic_stopping: float = 0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>This function should take the data and return the unfolded data</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def unfold(self, data: np.ndarray, data_errors: np.ndarray, efficiency: Optional[np.ndarray]=None, efficiency_errors: Optional[np.ndarray]=None, test_statistic: str=&#39;ks&#39;, test_statistic_stopping: float=0.01):
    &#39;&#39;&#39;
    This function should take the data and return the unfolded data
    &#39;&#39;&#39;
    if efficiency is None and efficiency_errors is None:
        efficiency = np.ones(data.shape[0]-1)
        efficiency_errors = np.zeros(data.shape[0]-1)
    unfolded_data = iterative_unfold(
        data=data, data_err=data_errors, response=self.response_matrix.getResponseMatrix(), response_err=self.response_matrix.getResponseMatrixError(), efficiencies=efficiency, efficiencies_err=efficiency_errors, ts=test_statistic, ts_stopping=test_statistic_stopping, cov_type=&#39;poisson&#39;, max_iter=100)
    self.unfolding_matrix = unfolded_data[&#39;unfolding_matrix&#39;]
    return unfolded_data</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="JetHadronAnalysis" href="index.html">JetHadronAnalysis</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="JetHadronAnalysis.Unfolding.ResponseMatrix" href="#JetHadronAnalysis.Unfolding.ResponseMatrix">ResponseMatrix</a></code></h4>
<ul class="">
<li><code><a title="JetHadronAnalysis.Unfolding.ResponseMatrix.buildResponseMatrix" href="#JetHadronAnalysis.Unfolding.ResponseMatrix.buildResponseMatrix">buildResponseMatrix</a></code></li>
<li><code><a title="JetHadronAnalysis.Unfolding.ResponseMatrix.buildResponseMatrixError" href="#JetHadronAnalysis.Unfolding.ResponseMatrix.buildResponseMatrixError">buildResponseMatrixError</a></code></li>
<li><code><a title="JetHadronAnalysis.Unfolding.ResponseMatrix.getResponseMatrix" href="#JetHadronAnalysis.Unfolding.ResponseMatrix.getResponseMatrix">getResponseMatrix</a></code></li>
<li><code><a title="JetHadronAnalysis.Unfolding.ResponseMatrix.getResponseMatrixError" href="#JetHadronAnalysis.Unfolding.ResponseMatrix.getResponseMatrixError">getResponseMatrixError</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="JetHadronAnalysis.Unfolding.Unfolder" href="#JetHadronAnalysis.Unfolding.Unfolder">Unfolder</a></code></h4>
<ul class="">
<li><code><a title="JetHadronAnalysis.Unfolding.Unfolder.refold" href="#JetHadronAnalysis.Unfolding.Unfolder.refold">refold</a></code></li>
<li><code><a title="JetHadronAnalysis.Unfolding.Unfolder.unfold" href="#JetHadronAnalysis.Unfolding.Unfolder.unfold">unfold</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>